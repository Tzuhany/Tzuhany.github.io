[{"title":"Trie树-并查集","url":"/2023/02/09/Trie%E6%A0%91-%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"并查集通常用于\n\n将两个集合合并\n查询两个元素是否在同一个集合中基本原理：每个集合用一颗树来表示，每个节点都存储其父节点，树根的编号就是集合的编号。判断树根：p[x] == x求x的集合编号：while(p[x] != x) x = p[x]，优化，进行路径压缩，一次找到根节点，将路径上所有点都直接指向根节点。这样可以基本保证O(1)的时间复杂度。合并两个集合：p[x] = y#include&lt;iostream&gt;using namespace std;const int N = 100010;//父节点元素int p[N];//返回x所在集合的编号//返回x的祖宗节点 + 路径压缩int find(int x) &#123;    if(x != p[x]) p[x] = find([px]);    return p[x];&#125;\n\nTrie树用来快速存储和查找字符串集合的数据结构Trie的插入和查询操作\n/*假设有下标为x的点son[x][]为下标x节点的所有子节点，son[x][0]就是x的第0个儿子cnt[x]是指以x结尾的点有多少个*/#include&lt;iostream&gt;using namespace std;int N = 100010;int son[N][26], cnt[N], idx;void insert(char[] str) &#123;    int p = 0;    for(int i = 0; str[i]; i++) &#123;        int u = str[i] - ‘a’;        if(!son[p][u]) son[p][u] = ++idx;        p = son[p]][u];    &#125;    cnt[p]++;&#125; int query(char[] str) &#123;    int p = 0;    for(int i = 0; str[i]; i++) &#123;        int u = str[i] - ‘a’;        if(!str[p][u]) return 0;        p = son[p][u];    &#125;    return cnt[p];&#125;\n\n","categories":["基础算法复习"],"tags":["算法"]},{"title":"Go数据结构","url":"/2023/01/30/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"切片在Go中，一般使用切片替代数组的使用，Go认为数组长度属于其类型的一部分，这可能导致[3]int的数组类型不同于定义为[4]int的类型，也意味着不能使用变量去指定数组长度，因为变量必须在编译时而不是在运行时解析。\n切片的定义：\n\n带字面量：var x = []int&#123;1, 2, 3&#125;\n不带字面量：var x []int，不带字面量时，由于切片没有被赋值，因此切片x被赋予零值nil\n\n切片中常用方法:\n\n切片长度len()，len(x)\n增加元素append()，可以添加单个值：x = append(x, 10)，也可以添加多个值x = append(x, 1, 2, 3, 4)，或者使用…操作符添加切片：x = append(x, y…)\n\n容量：切片是一个数值序列，切片中的值占用内存中的连续地址，切片在连续内存地址的大小就是切片的容量。容量可能会大于切片的长度，当最终所需长度超出容量的大小时，append函数使用Go运行时分配一个有更大容量的切片，将原切片的内容拷贝到新切片，将需要添加的值添加到新切片的末尾，并返回新切片。使用cap函数可以得到切片的容量。代码示例：\nvar x []intfat.Println(x, len(x), cap(x))x = append(x, 10)fat.Println(x, len(x), cap(x))x = append(x, 20)fat.Println(x, len(x), cap(x))x = append(x, 30)fat.Println(x, len(x), cap(x))x = append(x, 40)fat.Println(x, len(x), cap(x))x = append(x, 50)fat.Println(x, len(x), cap(x))answer:[] 0 0[10] 1 1[10 20] 2 2[10 20 30] 3 4[10 20 30 40] 4 4[10 20 30 40 50] 5 8\n在Go中，可以通过make函数创建所需容量的切片。x := make([]int, 5)，此时会创建一个长度为5，容量为5的整型切片。使用make创建切片后，不可以再使用append添加初始元素，如使用x = append(x, 10)，此时10会被添加至切片尾部，切片的容量会再增加一倍。可以指定切片的容量：x := make([]int, 5, 10)，此时创建了一个长度为5，容量为10的切片。也可以创建长度为0的切片，x := make([]int, 0, 5)，此时可以通过append方法向切片内追加数据。\n派生切片：在切片内使用:来生成派生切片。\nx := []int&#123;1, 2, 3, 4&#125;y := x[:2]fmt.Println(y)answer:[1 2]\n切片有时会共享内存，子切片的容量是原切片的容量减去切片的偏移量，因此，原切片为使用容量会和子切片共享。当改变x切片时，y也会随之改变。\n字符串，字符和字节参照切片，字符串同样有派生表达式来获取子串\nMap创建零值映射：var nilMap map[string]int创建字面量映射：totalMap := map[string]int&#123;&#125;\nMap的读写操作：\ndemoMap := map[string]int&#123;&#125;demoMap[“Amy”] = 98demoMap[“Tom”] = 90fmt.Println(demoMap[“Tom”])answer:90\n如果尝试读取Map中不存在的键，会返回0值，为了判断零值是由于该键不存在还是该键与零值相关联，我们可以使用ok模式。\n//接上述代码v, ok := demoMap[“Amy”]fmt.Println(v, ok)answer:98, true\n\ndelete函数可以删除Map中的键值delete(demoMap, “Amy”)\n映射模拟集合：\nintSet = map[int]bool&#123;&#125;vals := []int&#123;1, 3, 3, 5, 2, 9, 8&#125;for _, v := range vals &#123;    intSet[v] = true;&#125;\n因为映射中不会存在相同的键，因此所有相同的值只会被存放一次，当访问不存在的键时，会返回零值，对应bool的false\n结构体常规结构体的定义与访问：\ntype person struct&#123;    name string    age int    sex string&#125;//以下两种方式都会将结构体赋值零值var Tom personAmy := person&#123;&#125;//非空字面量赋值Sam := person&#123;    name: “Sam”,    age: 19,&#125;Tom.name = “Tom”\n匿名结构体：\nvar person struct &#123;    name string    age int    sex string   &#125;\n\n流程控制for - range：\ntmp := []int&#123;3, 4, 5&#125;for i, v := range tmp&#123;    fmt.Println(i, v)&#125;answer:0 31 42 5\n当不需要获取索引时，可以使用_来代替\n在嵌套循环中，可以使用outer标签跳出最外层循环\n","categories":["Go基础复习"],"tags":["Go"]},{"title":"堆","url":"/2023/02/09/%E5%A0%86/","content":"堆小根堆下标在1开始每一个点都小于等于左右子节点\n\n树的一位数组存储方式：索引为x的节点，左子节点为2x，右子节点为2x+1\n插入一个元素：在树的最后一个元素后插入，然后根据大小向上移动，heap[++size] = x; up(size)\n堆中的最小值：heap[1]\n堆中删除最小值：先使用最后一个点覆盖掉头节点，再把尾节点删掉，最后下沉头节点heap[1] = heap[size]; size—-; down(1)\n堆中删除任意一个元素：heap[k] = heap[size]; size—-，再根据k位元素变大还是变小使用down(k)或者up(k)\n堆中修改任意一个元素：heap[x] = k;在down(x)或者up(x)\n\n堆排序\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int h[N], cnt;//up操作void up(int u)&#123;    while(u / 2 &amp;&amp; h[u / 2] &lt; h[u]) &#123;        swap(h[u / 2], h[u]);        u /= 2;    &#125;&#125;void down(int u)&#123;    int t = u;    if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;    if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;    if (u != t)    &#123;        swap(h[u], h[t]);        down(t);    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]);    cnt = n;    for (int i = n / 2; i; i -- ) down(i);    while (m -- )    &#123;        printf(&quot;%d &quot;, h[1]);        h[1] = h[cnt -- ];        down(1);    &#125;    puts(&quot;&quot;);    return 0;&#125;\n当需要操作堆中第k个元素时，要加入映射关系acwing模拟堆：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;const int N = 100010;int h[N], ph[N], hp[N], cnt;void heap_swap(int a, int b)&#123;    swap(ph[hp[a]],ph[hp[b]]);    swap(hp[a], hp[b]);    swap(h[a], h[b]);&#125;void down(int u)&#123;    int t = u;    if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;    if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;    if (u != t)    &#123;        heap_swap(u, t);        down(t);    &#125;&#125;void up(int u)&#123;    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])    &#123;        heap_swap(u, u / 2);        u &gt;&gt;= 1;    &#125;&#125;int main()&#123;    int n, m = 0;    scanf(&quot;%d&quot;, &amp;n);    while (n -- )    &#123;        char op[5];        int k, x;        scanf(&quot;%s&quot;, op);        if (!strcmp(op, &quot;I&quot;))        &#123;            scanf(&quot;%d&quot;, &amp;x);            cnt ++ ;            m ++ ;            ph[m] = cnt, hp[cnt] = m;            h[cnt] = x;            up(cnt);        &#125;        else if (!strcmp(op, &quot;PM&quot;)) printf(&quot;%d\\n&quot;, h[1]);        else if (!strcmp(op, &quot;DM&quot;))        &#123;            heap_swap(1, cnt);            cnt -- ;            down(1);        &#125;        else if (!strcmp(op, &quot;D&quot;))        &#123;            scanf(&quot;%d&quot;, &amp;k);            k = ph[k];            heap_swap(k, cnt);            cnt -- ;            up(k);            down(k);        &#125;        else        &#123;            scanf(&quot;%d%d&quot;, &amp;k, &amp;x);            k = ph[k];            h[k] = x;            up(k);            down(k);        &#125;    &#125;    return 0;&#125;","categories":["基础算法复习"],"tags":["算法"]},{"title":"快排-归并-二分","url":"/2023/01/30/%E5%BF%AB%E6%8E%92-%E5%BD%92%E5%B9%B6-%E4%BA%8C%E5%88%86/","content":"快速排序\n确定分界点x，通常选取左端点，中间值或右端点\n调整区间，使得左区间都小于等于x，右区间都大于等于x\n递归处理左右两段调整区间的思路：当 q[i] &lt; x 或者 q[j] &gt; x时，双指针不停向中间移动，当两者都不满足条件，且i &lt; j时，交换值void quick_sort(int q[], int l, int r)&#123;    if(l &gt;= r) return;    int x = q[(l + r) / 2], I = l - 1, j = r + 1;    while(i &lt; j)&#123;        do i++; while(q[i] &lt; x);        do j—-; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);     &#125;    quick_sort(q, l, j);    quick_sort(q, j+1, r);&#125; \n\n归并排序\n选取中间点mid = （1 + r） / 2\n递归左右两区间，得到单调递增的左右区间\n归并左右两区间归并区间的思路：开辟新数组tmp，双指针i, j 分别指向两个区间的端点，将i, j指针指向较小的数放入tmp，当某段区间结束时，将另一段区间剩余的数直接接到ans数组最后。void merge_sort(int q[], int l, int r)&#123;    if(l &lt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);    int i = l, j = mid + 1, k = 0;    while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;        if(q[i] &lt;= q[j]) tmp[k++] = q[i++];        else tmp[k++] = q[j++];    &#125;    while(l &lt;= mid) tmp[k++] = q[i++];    while(j &lt;= r) tmp[k++] = q[j++];    for(i = l, j = 0; i &lt; r; i++, j++) q[i] = tmp[j];&#125;\n\n整数二分取中间值时需要注意，如果r = mid则中值取l + r &gt;&gt; 1，如果是l = mid则中值取l + r + 1 &gt;&gt;1题目示例：数的范围给定一个按照升序排列的长度为n的整数数组，以及q个查询。对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。如果数组中不存在该元素，则返回-1 -1。\nint main()&#123;    while(queryCount—-)&#123;        int l = 0, r = n - 1;        while(l &lt; r)&#123;            int mid = l + r &gt;&gt; 1;            if(q[mid] &gt;= x) r = mid;            else l = mid + 1;         &#125;        if(q[l] != x) cout &lt;&lt; “-1 -1” &lt;&lt; endl;        else &#123;            cout &lt;&lt; l &lt;&lt; “ ”;            int l = 0; r = n - 1;             while(l &lt; r)&#123;                int mid = l + r + 1 &gt;&gt; 1;                if(q[mid] &lt;= x) l = mid;                else r = mid - 1;            &#125;            cout &lt;&lt; l &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;\n\n浮点数二分int main()&#123;    double l = 0, r = x;    while(r - 1 &gt; 1e-6)&#123;        double mid = (l + r) / 2;        if(mid * mid &gt;= x) r = mid;        else l = mid;        &#125;    cout &lt;&lt; l;&#125;\n","categories":["基础算法复习"],"tags":["算法"]},{"title":"哈希","url":"/2023/02/09/%E5%93%88%E5%B8%8C/","content":"哈希拉链法对于数x，使用某个质数令x取模后，把余数作为下标存储，发生哈希冲突时，将发生冲突的数像链表一样接到发生冲突的数后面。\n模拟散列表：\n#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 100003;int h[N], e[N], ne[N], idx;void insert(int x)&#123;    int k = (x % N + N) % N;    e[idx] = x;    ne[idx] = h[k];    h[k] = idx ++ ;&#125;bool find(int x)&#123;    int k = (x % N + N) % N;    for (int i = h[k]; i != -1; i = ne[i])        if (e[i] == x)            return true;    return false;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    memset(h, -1, sizeof h);    while (n -- )    &#123;        char op[2];        int x;        scanf(&quot;%s%d&quot;, op, &amp;x);        if (*op == &#x27;I&#x27;) insert(x);        else        &#123;            if (find(x)) puts(&quot;Yes&quot;);            else puts(&quot;No&quot;);        &#125;    &#125;    return 0;&#125;\n\n开放寻址法\n#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 200003, null = 0x3f3f3f3f;int h[N];int find(int x)&#123;    int t = (x % N + N) % N;    while (h[t] != null &amp;&amp; h[t] != x)    &#123;        t ++ ;        if (t == N) t = 0;    &#125;    return t;&#125;int main()&#123;    memset(h, 0x3f, sizeof h);    int n;    scanf(&quot;%d&quot;, &amp;n);    while (n -- )    &#123;        char op[2];        int x;        scanf(&quot;%s%d&quot;, op, &amp;x);        if (*op == &#x27;I&#x27;) h[find(x)] = x;        else        &#123;            if (h[find(x)] == null) puts(&quot;No&quot;);            else puts(&quot;Yes&quot;);        &#125;    &#125;    return 0;&#125;\n\n字符串哈希acwing题目：字符串哈希\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ULL;const int N = 100010, P = 131;int n, m;char str[N];ULL h[N], p[N];ULL get(int l, int r)&#123;    return h[r] - h[l - 1] * p[r - l + 1];&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    scanf(&quot;%s&quot;, str + 1);    p[0] = 1;    for (int i = 1; i &lt;= n; i ++ )    &#123;        h[i] = h[i - 1] * P + str[i];        p[i] = p[i - 1] * P;    &#125;    while (m -- )    &#123;        int l1, r1, l2, r2;        scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);        if (get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;);        else puts(&quot;No&quot;);    &#125;    return 0;&#125;","categories":["基础算法复习"],"tags":["算法"]},{"title":"第一篇博客","url":"/2023/01/23/myFirstPost/","content":"折腾了许久，终于完成的自己的博客。\n建站之初，计划使用 React + Gin 进行博客的搭建，但最终还是放弃了，自己的审美实在过于糟糕，况且，写前端的时间足够学习很多东西，手撸一个博客对于一名大三在校生而言有些过于浪费时间了。\n最终选用 Hexo 进行博客的搭建，Hexo可以解析 MarkDown 文本，生成静态 HTML 页面，最最最重要的是，Hexo 提供了许多现成的主题，对主题不满意的地方可以直接对 CSS 进行修改，在魔改了两天之后，博客网站的样式终于到了我的审美上。\n博客采用 GitHub Page 进行部署，每一篇文章的更新相当于用 GIT 将代码提交到仓库里，再对仓库的 Custom domain 进行设置，把域名添加到上面，这样就可以直接通过域名对博客进行访问了。\n说到域名，还踩了很多坑，在腾讯云进行域名解析时，可以直接把记录类型设置为 CNAME 之后对 ping 一下仓库的地址，填到记录值上就好了，除此之外要在项目的 Source 文件夹下新建一个CNAME 文件，把域名填到里面，不然每次 commit 都要在仓库里重新绑定域名，离谱的很！\n搭建博客是为了督促自己多学习，多更新技术文章，希望能做到😢\n","categories":["杂语"],"tags":["杂语"]},{"title":"寄！","url":"/2023/02/09/%E6%80%82/","content":"记录今天，给女生要联系方式失败了，我太怂了啊啊啊！！！\n","categories":["日记"],"tags":["杂语"]},{"title":"链表-栈-队列","url":"/2023/02/09/%E9%93%BE%E8%A1%A8-%E6%A0%88-%E9%98%9F%E5%88%97/","content":"数组模拟静态链表使用数组模拟静态链表速度要显著快于使用结构体。\n#include&lt;iostream&gt;using namespace std;const N = 100010;/*其中head表示头节点指向的位置，e[N]表示该节点的值，ne[N]表示节点指向的下一个节点的索引，idx表示当前节点的索引*/int head, e[N], ne[N], idx; void init()&#123;    head = -1;    idx = 0;&#125;//在头节点插入void add_to_head(int x) &#123;    e[idx] = x;    ne[idx] = head;    head = idx;    idx++;&#125;//插入到k下标后void insert_k(int k, int x)&#123;    e[idx] = x;    ne[idx] = ne[k];    ne[k] = idx;    idx++&#125;//删除下标为k的点的后面的点void remove_k(int k)&#123;    ne[k] = ne[ne[k]];&#125;int main() &#123;    &#125;\n\n双向链表\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int e[N], l[N], r[N]void init()&#123;    r[0] = 1, l[1] = 0;    idx = 2;&#125;//在k的右边插入一个节点，当想要在k的左边插入节点时，可以写add(l[k], x)void add(int k, int x) &#123;    e[idx] = x;    l[idx] = k;    r[idx] = r[k];    l[r[k]] = idx;    r[k] = idx;    &#125;void remove(int k) &#123;    r[l[k]] = r[k];    l[r[k]] = l[k];&#125;int main()\n\n栈和队列\n#include&lt;iostream&gt;using namespace std;int stk[N], tt;//插入stk[++ tt] = x;//弹出tt—-//判断栈是否为空if(tt &gt; 0) not emptyelse empty栈顶stk[tt]//**********＊***********//队列int q[N], hh, tt//插入q[++tt] = x;//弹出hh++;//判断空if(hh &lt; tt) not emptyelse empty//取出队头元素q[hh]\n\n单调栈例题：找出数组中每个元素左边距离他最近且比他小的元素，没有返回-1思路：如果存在a[x] &lt; a[y] &amp;&amp; x &gt; y那a[y]永远都不会被输出出来，如此一来，可以直接在栈顶往下找，找到后吧新值入栈\n#include&lt;iostream&gt;using namespace std;const int N = 100010int n;int stk[N], tt;int main()&#123;    cin &gt;&gt; n;    for(int i = 0; i &lt; n; i++) &#123;        int x;        cin &gt;&gt; x;        while(tt &amp;&amp; stk[tt] &gt;= x) tt—-;        if(tt) cout &lt;&lt; stk[tt] &lt;&lt; “ ”;        else cout &lt;&lt; -1 &lt;&lt; “ ”;        stk[++t] = x;         &#125;    return 0;   &#125;\n\n\n单调队列滑动窗口问题\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int n, k;int a[N], q[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; k;    for(int i = 0; i &lt; n; i++ ) &#123;        if(hh &lt;= tt &amp;&amp; i - k +1 &gt; q[hh]) h++;        while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) t—-;        q[++t] = i;        if(i &gt;= k - 1) cout &lt;&lt; a[q[hh]];        puts(“”);    &#125;    puts(“”);        hh = 0, tt = -i;    for(int i = 0; i &lt; n; i++) &#123;        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++;        while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) t—-;        q[++t] = i;        if(i &gt;= k - 1) cout &lt;&lt; a[q[hh]];    &#125;    puts(“”);&#125;","categories":["基础算法复习"],"tags":["算法"]},{"title":"高精度-前缀和-差分","url":"/2023/02/09/%E9%AB%98%E7%B2%BE%E5%BA%A6-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/","content":"高精度大整数存储：使用数组存取大整数，由于在数组的末尾添加值要比在开头添加容易，因此数组的0位一般存取大整数的个位。高精度在很多需要求补位的题目中会遇到。\n高精度加法：\nvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size() || i &lt; B.size(); i++)&#123;        //A + B结果存到t中        if(i &lt; A.size()) t += A[i];        if(i &lt; B.size()) t += B[i];                //个位存到C中        C.push_back(t % 10);                //如果t &gt; 10, t取进位        t /= 10;    &#125;    if(t) C.push_back(t);    return C;&#125;\n\n高精度减法：\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size() || i &lt; B.size(); i++)&#123;        //t 等于被减数减去借位        t = A[i] - t;        if(i &lt; B.size()) t -= B[i];        C.push_back((t + 10) % 10);                //如果 t &lt; 0 证明存在借位        if(t &lt; 0) t = 1;        else t = 0;    &#125;    //把结果前面的0去掉    while(C.size() &gt; 1 &amp;&amp; c.back() == 0) C.pop_back();    return C;&#125;\n高精度乘法：\nvector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, b)&#123;    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size() || t; i++)&#123;        if(i &lt; A.size()) t += A[i] * b;        C.push_back(t % 10);        t /= 10;    &#125;    return 10;&#125;\n高精度除法：\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123;    vector&lt;int&gt; C;    r = 0;    for(int i = A.size() - 1; i &gt;= 0; i ++)&#123;        r = r * 10 + A[i];        C.push_back(r / b);        r %= b;    &#125;    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;&#125;\n\n前缀和for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];for(int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i];\n差分差分为前缀和的逆运算，假设存在a[], b[]，使得a[i] = b[1] + b[2] + … + b[i]，构造方法为b[i] = a[i] - a[i - 1]\n","categories":["基础算法复习"],"tags":["算法"]}]