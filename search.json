[{"title":"01背包问题","url":"/2023/02/10/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","content":"今天开始了动态规划的学习，看着y总的闫氏DP分析法，学会了最基础的01背包问题。\n\n01背包问题#include&lt;iostream&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int dp[N][N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];    for(int i = 1; i &lt;= n; i++)&#123;        for(int j = 0; j &lt;= m; j++) &#123;            dp[i][j] = dp[i - 1][j];            if(v[i] &lt;= j) dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]);        &#125;    &#125;        cout&lt;&lt;dp[n][m];&#125;","categories":["基础算法复习"],"tags":["算法"]},{"title":"DFS-BFS","url":"/2023/02/09/DFS-BFS/","content":"深度优先搜索与广度优先搜索通常用于树和图的操作，经典深度优先搜索例题如八皇后问题。\n\n\n深度优先搜索（DFS）从树的头节点开始，自最左树开始向下搜索，到达叶子节点后回溯，直至搜索完毕。leetcode200.岛屿数量\nclass Solution &#123;public:    int dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j) &#123;        //添加递归限定条件        if (i &lt; 0 || j &lt; 0 || i &gt;= grid.size() || j &gt;= grid[0].size() || grid[i][j] == &#x27;0&#x27;) &#123;            return 0;        &#125;        //最重要的一步，递归的过程中，将每一个岛屿的所有点赋值为0        grid[i][j] = &#x27;0&#x27;;        for (int index = 0; index &lt; 4; ++index) &#123;            int next_i = i + di[index];            int next_j = j + dj[index];            df(grid, next_i,next_j);        &#125;        return 1;    &#125;     int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;        int num = 0;        //对每一个节点进行dfs        for (int i = 0; i &lt; grid.size(); ++i) &#123;            for (int j = 0; j &lt; grid[0].size(); ++j) &#123;                num += dfs(grid, i, j);             &#125;        &#125;        return num;    &#125;private:        int di[4] = &#123;-1,0,1,0&#125;;        int dj[4] = &#123;0,1,0,-1&#125;;&#125;;\n例题：acwing 842.排列数字通过递归与回溯的思想实现深度优先搜索\n#include&lt;iostream&gt;using namespace std;const int N = 8;int n, path[N];bool st[N];void dfs(int u)&#123;    //递归终止的条件为最内层循环终止    if(u == n)&#123;         for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, path[i]);        puts(&quot;&quot;);            &#125;;        for(int i = 1; i &lt;= n; i++)&#123;        if(!st[i])&#123;            path[u] = i;            st[i] = true;            dfs(u + 1);            st[i] = false;        &#125;            &#125;&#125;int main()&#123;    cin &gt;&gt; n;    dfs(0);    return 0;&#125;\n\n广度优先搜索（BFS）从头节点开始，搜索每一层的所有节点。acwing迷宫问题\n#include&lt;iostream&gt;#include&lt;cstring&gt;typedef pair&lt;int, int&gt; PIIconst N = 110;//给定高度与宽度int n, m;//存储图int g[N][N];//记录每个点距离起点的距离int d[N][N];int bfs() &#123;    //给图中所有点赋值为-1，-1代表还没走过    memset(d, -1, sizeof d);    queue&lt;PII&gt; q;    //图中第一个点赋值为0，代表起始走到了第一个点    d[0, 0] = 0;    q.push(&#123;0, 0&#125;);    //设置方向    int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;    while(q.size())&#123;        auto t = q.front();        q.pop();                //遍历到达的每个点的四个方向        for(int i = 0; i &lt; 4; i++) &#123;            int x = t.first + dx[i], y = t.second + dy[i];             if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] == 0 &amp;&amp; d[x][y] == -1) &#123;            //d[x][y]等于上一个节点加一            d[x][y] = d[t.first][t.second] + 1;            q.push(&#123;x, y&#125;);        &#125;    &#125;    return d[n - 1][m - 1];&#125;int main()&#123;    for(int i = 0; i &lt; n; i++)        for(int j = 0; j &lt; m; j++)            cin &gt;&gt; g[i][j];    cout &lt;&lt; bfs() &lt;&lt; endl;&#125;","categories":["基础算法复习"],"tags":["算法"]},{"title":"Trie树-并查集","url":"/2023/02/09/Trie%E6%A0%91-%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"并查集通常用于\n\n将两个集合合并\n查询两个元素是否在同一个集合中基本原理：每个集合用一颗树来表示，每个节点都存储其父节点，树根的编号就是集合的编号。判断树根：p[x] == x求x的集合编号：while(p[x] != x) x = p[x]，优化，进行路径压缩，一次找到根节点，将路径上所有点都直接指向根节点。这样可以基本保证O(1)的时间复杂度。合并两个集合：p[x] = y#include&lt;iostream&gt;using namespace std;const int N = 100010;//父节点元素int p[N];//返回x所在集合的编号//返回x的祖宗节点 + 路径压缩int find(int x) &#123;    if(x != p[x]) p[x] = find([px]);    return p[x];&#125;\n\nTrie树用来快速存储和查找字符串集合的数据结构Trie的插入和查询操作\n/*假设有下标为x的点son[x][]为下标x节点的所有子节点，son[x][0]就是x的第0个儿子cnt[x]是指以x结尾的点有多少个*/#include&lt;iostream&gt;using namespace std;int N = 100010;int son[N][26], cnt[N], idx;void insert(char[] str) &#123;    int p = 0;    for(int i = 0; str[i]; i++) &#123;        int u = str[i] - ‘a’;        if(!son[p][u]) son[p][u] = ++idx;        p = son[p]][u];    &#125;    cnt[p]++;&#125; int query(char[] str) &#123;    int p = 0;    for(int i = 0; str[i]; i++) &#123;        int u = str[i] - ‘a’;        if(!str[p][u]) return 0;        p = son[p][u];    &#125;    return cnt[p];&#125;\n\n","categories":["基础算法复习"],"tags":["算法"]},{"title":"MySQL基础","url":"/2023/02/25/MySQL%E5%9F%BA%E7%A1%80/","content":"使用DISTINCT关键字，指示MySQL 列中只返回不同的值\n\n\nselect DISTINCT vend_id from products\n\n使用LIMIT限制返回结果\n-- 限制输出结果只有五行select prod_name from products LIMIT 5-- 返回从行5开始的5行select prod_name from products LIMIT 5,5\n\nIS NULL空值过滤\nselect prod_name from products where prod_price IS NULL\n\nLIKE通配符\n-- 筛选以jet开头的数据select prod_id, prod_name from products where prod_name LIKE &#x27;jet%&#x27;-- 筛选所有包含jet的数据select prod_id, prod_name from products where prod_name LIKE &#x27;%jet%&#x27;-- 筛选以s开头，e结尾的数据select prod_id, prod_name from products where prod_name LIKE &#x27;s%e&#x27;\n\n下划线_通配符\n-- 下划线通配符只匹配单个字符select prod_id, prod_name from products where prod_name LIKE &#x27;_tom anvi1&#x27;\n\n正则表达式搜索-- 匹配1000， 2000 ……select prod_id, prod_name from products where prod_name REGEXP &#x27;.000&#x27;select prod_id, prod_name from products where prod_name REGEXP &#x27;1000|2000&#x27;-- 匹配1 ton， 2ton， 3tonselect prod_id, prod_name from products where prod_name REGEXP &#x27;[1-3] ton&#x27;-- 匹配特殊字符. - 等select prod_id, prod_name from products where prod_name REGEXP &#x27;\\\\.&#x27;-- 匹配连在一起的4个数字select prod_id, prod_name from products where prod_name REGEXP [[:digit:]]&#123;4&#125;\n\n拼接字段\n-- 输出 杨子涵（男）select concat(name, &#x27;(&#x27;, sex, &#x27;)&#x27;) from infos\n\n去除空格\nselect RTrim(name) from infos\n\n使用别名AS\nselect concat(name, &#x27;(&#x27;, sex, &#x27;)&#x27;) as basic_info from infos\n\n分组-- 统计每个id有多少个select id, count(*) from products group by id-- 要列出至少有两个订单的所有顾客，由于where指定的是行，而having指定的是分组，因此要使用havingselect cust_id, count(*) as numorder from orders group by cust_id having count(*) &gt;= 2-- 列出具有2个（含）以上、价格为10（含）以上的产品的供应商select vend_id, count(*) as num_prodsfrom productswhere prod_price &gt;= 10group by vent_idhaving count(*) &gt;= 2\n\n子查询-- 列出订购物品TNT2的所有客户-- 不使用子查询-- 1)select order_num from orderitems where prod_id = &#x27;TNT2&#x27;-- 2)select cust_id from orders where order_num in(20005, 20007)-- 使用子查询select cust_id from orders where order_num in(select order_num from orderitems where prod_id = &#x27;TNT2&#x27;)\n\n连结表-- 内联结select vend_name, prod_name, prod_pricefrom vendors inner join productson vendors.vend_id = products.vend_id-- 自联结-- 使用AS在SQL中多次使用相同表select p1.prod_id, p1.prod_namefrom products as p1, products as p2where p1.vend_id = p2.vend_id-- 外联结-- right表示选择右边表的所有行select vend_name, prod_name, prod_pricefrom vendors right outer join productson vendors.vend_id = products.vend_id\n\n组合查询\n-- 使用UNION组合多个查询select vend_id, prod_id, prod_pricefrom productswhere prod_price &lt;= 5-- union会自动删除重复的行，如果取消，使用union allunion (union all)select vend_id, prod_id, prod_pricefrom productswhere vend_id in (1001, 1002)-- 最后使用排序，会对整个结果都排序order by vend_id, prod_price\n\n全文搜索创建表时，启用全文搜索\ncreate table productnotes(\tnote_id\t\tint\t\t\tnot null auto_increment,    prod_id \tchar(10)\tnot null,    note_date \tdatetime\tnot null,    note_text\ttext\t\tnull,    primary key(note_id),    fulltext(note_text))engine=myisam-- 检索出包含rabbit的记录select note_textfrom productnoteswhere match(note_text) against(&#x27;rabbit&#x27;)-- 布尔文本搜索-- 不包含rabbit的记录select note_textfrom productnoteswhere match(note_text) against(&#x27;rabbit&#x27;, IN BOOLEAN MODE)-- 包含rabbit。但不包含haven的记录select note_textfrom productnoteswhere match(note_text) against(&#x27;rabbit -rope*&#x27;, IN BOOLEAN MODE)\n\n插入检索出的数据insert into customers(\tid,    phone,    email)selectid,phone,emailfrom infos\n\n更新表alter table vendors add vend_phone char(20)alter table vendors drop column vend_phonealter table orders add constraint products_vendors foreign key (vend_id) references vendors (vend_id)\n\n存储过程-- 创建存储过程create procedure productpricing()begin\tselect avg(prod_price) as priceaverge\tfrom products;end;-- 调用存储过程call productpricing()-- 删除存储过程drop procedure productpricing if exists;-- 传递变量-- MySQL支持IN（传递给存储过程）、OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。create procedure productpricing(\tout p1 decimal(8, 2)    out ph decimal(8, 2)    out pa decimal(8, 2))begin\tselect min(prod_price)\tinto p1\tfrom products;\tselect max(prod_price)\tinto ph\tfrom products;\tselect avg(prod_price)\tinto pa\tfrom products;end;call productpricing(\t@pricelow    @pricehigh    @priceaverage)select @pricelow, @pricehigh, @priceaverage;-- 使用传入示例create procedure productpricing(\tin onumber int,    out ototal decimal(8, 2))begin\tselect sum(item_price * quantity)\tfrom orderitems\twhere order_num = onumber\tinto totalend call productpricing(\t200005,    @total)select @total\n\n完成存储过程示例\ncreate procedure ordertotal(\tin onumber int,    in taxable boolen,    out ototal decimal(8, 2))comment &#x27;obtain order total, optionally adding tax&#x27;begin\tdeclare total decimal(8, 2);\tdeclare tax int default 6;\t\tselect sum(item_price * quantity)\tfrom orderitems\twhere order_num = onumber\tinto total;\t\tif taxable then\t\tselect total + (total / 100 * taxrate) into total;\tend if;\t\tselect total into ototalend;call ordertotal(20005, 0, @total);select @total;-- 检查存储过程show create procedure ordertotal;\n\n游标MySQL检索操作返回一组称为结果集的行。这组返 回的行都是与SQL语句相匹配的行（零行或多行）。使用简单的SELECT语 句，例如，没有办法得到第一行、下一行或前10行，也不存在每次一行 地处理所有行的简单方法（相对于成批地处理它们）。 有时，需要在检索出来的行中前进或后退一行或多行。这就是使用 游标的原因。游标（cursor）是一个存储在MySQL服务器上的数据库查询， 它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游 标之后，应用程序可以根据需要滚动或浏览其中的数据。\n-- 此时ordernumbers存游标存储了select的结果集，可根据需要打开游标逐行滑动数据create procedure processorders()begin\tdeclare o int; \tdeclare ordernumbers cursor\tfor\tselect order_num from orders;\t-- 游标执行完之后将done设置为1\tdeclare continue handler for not found set done = 1;\topen ordernumbers;\trepeat\t\tfetch ordernumbers into o;\tuntil done end repeat;\tclose ordernumbers;end;\n\n\n\ncreate procedure processorders()begin\tdeclare done boolean default 0;\tdeclare o int;\tdeclare t decimal(8, 2);\t\tdeclare ordernumbers cursor;\tdeclare continue handler for not found set done = 1;\t\tcreate table if not exists ordertotals(    \torder_num int,        total decimal(8, 2)    )    open ordernumbers;        repeat    \tfetch ordernumbers into o;    \tcall ordertotal(0, 1, t);    \tinsert into ordertotals(order_num, total) values(0, t);    until done end repeat;        close ordernumbers;    end;\t\n\n触发器想要某些语句在事件发生时自动执行，使用触发器\n每个表的每个事件每次只允许一个触发器\n-- 在进行每一行插入时执行create trigger newproduct after insert on productsfor each row select &#x27;product added&#x27;;-- 删除触发器drop trigger newproduct;-- 在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；-- 在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；-- 在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；-- 返回插入新值的order_numcreate trigger newproduct after insert on productsfor each row select new.order_num-- 使用OLD保存将要被删除的行到一个存档表中create trigger deleteorder before delete on ordersfor each rowbegin\tinsert into archive_orders(order_num, order_date, cust_id)\tvalues(old.order_num, old.order_date, old.cust_id);end;-- 下面的例子保证州名缩写总是大写create trigger deleteorder before update on vendorsfor each row set new.vend_state = upper(new.vend_state);\n\n事务处理为了防止执行一段sql操作时，某一个sql语句出现错误，所以要使用事务来防止出错\n-- 1-回退select * from ordertotals;-- 开启一个事务start transaction;-- 删除ordertotals中的所有内容delete from ordertotals;-- 此时ordertotals表为空select * from ordertotals;-- 回退start transaction之后的所有操作rollback;-- 此时ordertotals表不为空select * from ordertotals;-- 2-提交start transaction;delete from ordertotals where order_num = 20010;delete from orders where order_num = 20010;-- 提交，此时如果上面的某条delete语句出错，则两条delete语句都不会执行commit;-- 3-保留点，在某个步骤出错时，不用全部回退，只回退到出错点start transaction;savepoint delete1;delete from ordertotals where order_num = 20010;savepoint delete2;delete from orders where order_num = 20010;rollback delete1;commit;","categories":["MySQL"],"tags":["MySQL基础"]},{"title":"Go数据结构","url":"/2023/01/30/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"切片在Go中，一般使用切片替代数组的使用，Go认为数组长度属于其类型的一部分，这可能导致[3]int的数组类型不同于定义为[4]int的类型，也意味着不能使用变量去指定数组长度，因为变量必须在编译时而不是在运行时解析。\n切片的定义：\n\n带字面量：var x = []int&#123;1, 2, 3&#125;\n不带字面量：var x []int，不带字面量时，由于切片没有被赋值，因此切片x被赋予零值nil\n\n切片中常用方法:\n\n切片长度len()，len(x)\n增加元素append()，可以添加单个值：x = append(x, 10)，也可以添加多个值x = append(x, 1, 2, 3, 4)，或者使用…操作符添加切片：x = append(x, y…)\n\n容量：切片是一个数值序列，切片中的值占用内存中的连续地址，切片在连续内存地址的大小就是切片的容量。容量可能会大于切片的长度，当最终所需长度超出容量的大小时，append函数使用Go运行时分配一个有更大容量的切片，将原切片的内容拷贝到新切片，将需要添加的值添加到新切片的末尾，并返回新切片。使用cap函数可以得到切片的容量。代码示例：\nvar x []intfat.Println(x, len(x), cap(x))x = append(x, 10)fat.Println(x, len(x), cap(x))x = append(x, 20)fat.Println(x, len(x), cap(x))x = append(x, 30)fat.Println(x, len(x), cap(x))x = append(x, 40)fat.Println(x, len(x), cap(x))x = append(x, 50)fat.Println(x, len(x), cap(x))answer:[] 0 0[10] 1 1[10 20] 2 2[10 20 30] 3 4[10 20 30 40] 4 4[10 20 30 40 50] 5 8\n在Go中，可以通过make函数创建所需容量的切片。x := make([]int, 5)，此时会创建一个长度为5，容量为5的整型切片。使用make创建切片后，不可以再使用append添加初始元素，如使用x = append(x, 10)，此时10会被添加至切片尾部，切片的容量会再增加一倍。可以指定切片的容量：x := make([]int, 5, 10)，此时创建了一个长度为5，容量为10的切片。也可以创建长度为0的切片，x := make([]int, 0, 5)，此时可以通过append方法向切片内追加数据。\n派生切片：在切片内使用:来生成派生切片。\nx := []int&#123;1, 2, 3, 4&#125;y := x[:2]fmt.Println(y)answer:[1 2]\n切片有时会共享内存，子切片的容量是原切片的容量减去切片的偏移量，因此，原切片为使用容量会和子切片共享。当改变x切片时，y也会随之改变。\n字符串，字符和字节参照切片，字符串同样有派生表达式来获取子串\nMap创建零值映射：var nilMap map[string]int创建字面量映射：totalMap := map[string]int&#123;&#125;\nMap的读写操作：\ndemoMap := map[string]int&#123;&#125;demoMap[“Amy”] = 98demoMap[“Tom”] = 90fmt.Println(demoMap[“Tom”])answer:90\n如果尝试读取Map中不存在的键，会返回0值，为了判断零值是由于该键不存在还是该键与零值相关联，我们可以使用ok模式。\n//接上述代码v, ok := demoMap[“Amy”]fmt.Println(v, ok)answer:98, true\n\ndelete函数可以删除Map中的键值delete(demoMap, “Amy”)\n映射模拟集合：\nintSet = map[int]bool&#123;&#125;vals := []int&#123;1, 3, 3, 5, 2, 9, 8&#125;for _, v := range vals &#123;    intSet[v] = true;&#125;\n因为映射中不会存在相同的键，因此所有相同的值只会被存放一次，当访问不存在的键时，会返回零值，对应bool的false\n结构体常规结构体的定义与访问：\ntype person struct&#123;    name string    age int    sex string&#125;//以下两种方式都会将结构体赋值零值var Tom personAmy := person&#123;&#125;//非空字面量赋值Sam := person&#123;    name: “Sam”,    age: 19,&#125;Tom.name = “Tom”\n匿名结构体：\nvar person struct &#123;    name string    age int    sex string   &#125;\n\n流程控制for - range：\ntmp := []int&#123;3, 4, 5&#125;for i, v := range tmp&#123;    fmt.Println(i, v)&#125;answer:0 31 42 5\n当不需要获取索引时，可以使用_来代替\n在嵌套循环中，可以使用outer标签跳出最外层循环\n","categories":["Go基础复习"],"tags":["Go"]},{"title":"第一篇博客","url":"/2023/01/23/myFirstPost/","content":"折腾了许久，终于完成的自己的博客。\n建站之初，计划使用 React + Gin 进行博客的搭建，但最终还是放弃了，自己的审美实在过于糟糕，况且，写前端的时间足够学习很多东西，手撸一个博客对于一名大三在校生而言有些过于浪费时间了。\n最终选用 Hexo 进行博客的搭建，Hexo可以解析 MarkDown 文本，生成静态 HTML 页面，最最最重要的是，Hexo 提供了许多现成的主题，对主题不满意的地方可以直接对 CSS 进行修改，在魔改了两天之后，博客网站的样式终于到了我的审美上。\n博客采用 GitHub Page 进行部署，每一篇文章的更新相当于用 GIT 将代码提交到仓库里，再对仓库的 Custom domain 进行设置，把域名添加到上面，这样就可以直接通过域名对博客进行访问了。\n说到域名，还踩了很多坑，在腾讯云进行域名解析时，可以直接把记录类型设置为 CNAME 之后对 ping 一下仓库的地址，填到记录值上就好了，除此之外要在项目的 Source 文件夹下新建一个CNAME 文件，把域名填到里面，不然每次 commit 都要在仓库里重新绑定域名，离谱的很！\n搭建博客是为了督促自己多学习，多更新技术文章，希望能做到😢\n","categories":["杂语"],"tags":["杂语"]},{"title":"Shell","url":"/2023/02/25/Shell/","content":"循环， 函数， 文件重定向\n\n\n循环\nfor var in val1 val2 val3do\t#语句一\t#语句二done#例子for file in `ls`do\techo $filedone#会输出所有文件的名称\n\nfor((i=1; i&lt;=10; i++))do\techo $idone\n\nwhile read filedo\techo $namedone\n\nuntil conditiondo\t#语句一\t#语句二done\n\n#输出1 - 10内的所有奇数for((i=1; i&lt;=10;i++))do\tif [`expr $i % 2` -eq 0]\tthen\t\tcontinue\tfi\techo $idone\n\n\n\n函数\nfunc()&#123;\tname=yzh\techo $name\t\treturn 123&#125;output=$(func)ret=$?#传递参数时，$0代表文件名，$1代表第一个参数，以此类推func()&#123;\tnum1=$1\tnum2=$2\techo $num1\techo $num2&#125;func 1 2\n\n\n\n文件重定向\ncommand &gt; file #将stdout重定向到file中command &lt; file #将stdin重定向到file中command &gt;&gt; file #将stdout以追加的方式重定向到file中command n &gt; file #将文件描述符n重定向到file中command n &gt;&gt; file #将文件描述符n以追加方式重定向到file中\n\necho -e &quot;Hello&quot; &gt; output.txtecho &quot;World&quot; &gt;&gt; output.txtread str &lt; output.txt\n\n\n\n","categories":["Linux"],"tags":["Linux"]},{"title":"java多线程（一）","url":"/2023/03/01/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/","content":"第一集\n\n继承Thread类实现多线程public class ThreadDemo extends Thread&#123;    @Override    public void run()&#123;        for(int i  = 0; i &lt; 20; i++)&#123;            System.out.println(i + &quot;---子线程&quot;);        &#125;    &#125;    public static void main(String[] args)    &#123;        ThreadDemo threadTest = new ThreadDemo();        threadTest.start();        for(int i  = 0; i &lt; 20; i++)&#123;            System.out.println(i + &quot;---主线程&quot;);        &#125;    &#125;&#125;/*输出结果0---子线程1---子线程2---子线程3---子线程4---子线程5---子线程6---子线程7---子线程8---子线程0---主线程9---子线程1---主线程2---主线程3---主线程4---主线程5---主线程6---主线程10---子线程7---主线程8---主线程9---主线程10---主线程11---主线程12---主线程13---主线程14---主线程15---主线程11---子线程16---主线程12---子线程13---子线程14---子线程15---子线程16---子线程17---子线程18---子线程19---子线程17---主线程18---主线程19---主线程 */\n\n实现Runnable接口（推荐使用）public class ThreadDemo implements Runnable &#123;    @Override    public void run() &#123;        for (int i = 1; i &lt;= 20; i++) &#123;            System.out.println(i + &quot;---子线程&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        ThreadDemo threadTest = new ThreadDemo();        new Thread(threadTest).start();        for (int i = 1; i &lt;= 20; i++) &#123;            System.out.println(i + &quot;---主线程&quot;);        &#125;    &#125;&#125;/*输出结果1---子线程2---子线程3---子线程4---子线程5---子线程6---子线程7---子线程8---子线程1---主线程2---主线程3---主线程9---子线程4---主线程5---主线程6---主线程7---主线程8---主线程9---主线程10---主线程11---主线程10---子线程11---子线程12---子线程13---子线程14---子线程15---子线程16---子线程12---主线程13---主线程14---主线程17---子线程15---主线程16---主线程17---主线程18---主线程18---子线程19---主线程19---子线程20---子线程20---主线程*/\n\n初识并发问题public class ThreadDemo implements Runnable &#123;    private int ticketNum = 10;    @Override    public void run() &#123;        while (true) &#123;            if (ticketNum &lt;= 0) break;            //模拟延时            try &#123;                Thread.sleep(200);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName() + &quot;--&gt; 拿到了第&quot; + ticketNum-- + &quot;张票&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        ThreadDemo ticket = new ThreadDemo();        new Thread(ticket, &quot;张三&quot;).start();        new Thread(ticket, &quot;李四&quot;).start();        new Thread(ticket, &quot;黄牛&quot;).start();    &#125;&#125;/*输出结果黄牛--&gt; 拿到了第9张票张三--&gt; 拿到了第10张票李四--&gt; 拿到了第9张票张三--&gt; 拿到了第8张票黄牛--&gt; 拿到了第8张票李四--&gt; 拿到了第8张票黄牛--&gt; 拿到了第7张票张三--&gt; 拿到了第6张票李四--&gt; 拿到了第5张票张三--&gt; 拿到了第3张票黄牛--&gt; 拿到了第4张票李四--&gt; 拿到了第4张票李四--&gt; 拿到了第2张票黄牛--&gt; 拿到了第1张票张三--&gt; 拿到了第2张票*///此时多个线程操作同一个对象时，线程不安全，会出现重复抢票的现象\n\n模拟龟兔赛跑问题public class Race implements Runnable &#123;    private static String winnner;    @Override    public void run() &#123;        for (int i = 0; i &lt;= 100; i++) &#123;            boolean flag = gameOver(i);            if (flag) break;            //模拟兔子跑10步后睡觉            if (Thread.currentThread().getName().equals(&quot;兔子&quot;) &amp;&amp; i % 10 == 0) &#123;                try &#123;                    Thread.sleep(3);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (winnner == null)                System.out.println(Thread.currentThread().getName() + &quot;--&gt;跑了&quot; + i + &quot;步&quot;);        &#125;    &#125;    private boolean gameOver(int steps) &#123;        if (winnner != null) return true;        else &#123;            if (steps &gt;= 100) &#123;                winnner = Thread.currentThread().getName();                System.out.println(&quot;winner is &quot; + winnner);                return true;            &#125;        &#125;        return false;    &#125;    public static void main(String[] args) &#123;        Race race = new Race();        new Thread(race, &quot;兔子&quot;).start();        new Thread(race, &quot;乌龟&quot;).start();    &#125;&#125;\n\nLamda表达式简化函数式接口的调用\npublic class LambdaDemo &#123;    public static void main(String[] args) &#123;        iLike like = () -&gt; &#123;            System.out.println(&quot;This is lambda&quot;);        &#125;;        like.lambda();    &#125;&#125;// 1. 定义一个函数式接口（只有一个抽象方法的接口）interface iLike &#123;    void lambda();&#125;\n\n线程停止建议使用flag标志位使得线程停止\npublic class StopDemo implements Runnable &#123;    // 1. 设置标志位    private boolean flag = true;    @Override    public void run() &#123;        int i = 0;        while (flag) &#123;            System.out.println(&quot;Thread running ......&quot; + i++);        &#125;    &#125;    public void stop() &#123;        this.flag = false;    &#125;    public static void main(String[] args) &#123;        StopDemo stopDemo = new StopDemo();        new Thread(stopDemo).start();        for (int i = 0; i &lt; 100; i++) &#123;            System.out.println(&quot;main&quot; + i);            if (i == 90) &#123;                stopDemo.stop();                System.out.println(&quot;线程终止&quot;);            &#125;        &#125;    &#125;&#125;\n\n线程休眠//倒计时模拟import java.text.SimpleDateFormat;import java.util.Date;public class StopDemo &#123;    public static void main(String[] args) &#123;        Date currentTime = new Date(System.currentTimeMillis());        while (true) &#123;            try &#123;                Thread.sleep(1000);                System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(currentTime));                currentTime = new Date(System.currentTimeMillis());            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;\n\nyield线程礼让让线程从运行态转换为就绪态\npublic class YeildDemo &#123;    public static void main(String[] args) &#123;        Myield myield = new Myield();        new Thread(myield, &quot;a&quot;).start();        new Thread(myield, &quot;b&quot;).start();    &#125;&#125;class Myield implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(Thread.currentThread().getName() + &quot;线程开始执行&quot;);        Thread.yield(); // 礼让        System.out.println(Thread.currentThread().getName() + &quot;线程暂停执行&quot;);    &#125;&#125;/*礼让后的执行结果b线程开始执行a线程开始执行b线程暂停执行a线程暂停执行*/\n\n线程强制执行join//抢占其他线程public class joinDemo implements Runnable &#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            System.out.println(&quot;插入线程&quot; + i);        &#125;    &#125;    public static void main(String[] args) &#123;        joinDemo joinDemo = new joinDemo();        Thread joinThread = new Thread(joinDemo);        joinThread.start();        for (int i = 0; i &lt; 10; i++) &#123;            if (i == 4) &#123;                try &#123;                    joinThread.join();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            System.out.println(&quot;main线程&quot; + i);        &#125;    &#125;&#125;/*输出结果main线程0main线程1main线程2main线程3插入线程0插入线程1插入线程2插入线程3插入线程4插入线程5插入线程6插入线程7插入线程8插入线程9main线程4main线程5main线程6main线程7main线程8main线程9*/\n\n观测线程状态\nNEW：尚未启动的线程状态\nRUNNABLE：在java虚拟机中执行的线程处于此状态\nBLOCKED：被阻塞等待监视器锁定的线程处于此状态\nWAITING：正在等待另一个线程执行特定动作的线程处于此状态\nTIMED_WAITING：正在等待另一个线程动作达到指定等待时间的线程处于此状态\nTERMINATED：已退出的线程处于此状态\n\npublic class joinDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread thread = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 3; i++) &#123;                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            System.out.println(&quot;线程执行完毕&quot;);        &#125;);        //定义线程状态        Thread.State state = thread.getState();        System.out.println(state); // NEW        thread.start();        state = thread.getState();        System.out.println(state); //RUNNABLE        while (thread.getState() != Thread.State.TERMINATED) &#123;            Thread.sleep(100);            state = thread.getState();            System.out.println(state);        &#125;    &#125;&#125;/*执行结果NEWRUNNABLETIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITING线程执行完毕TERMINATED*/\n\n线程优先级优先级高的线程不一定先跑，只是先跑的概率比较大\npublic class PriorityDemo implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + Thread.currentThread().getPriority());    &#125;    public static void main(String[] args) &#123;        System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + Thread.currentThread().getPriority());        PriorityDemo priorityDemo = new PriorityDemo();        Thread thread1 = new Thread(priorityDemo, &quot;a&quot;);        Thread thread2 = new Thread(priorityDemo, &quot;b&quot;);        Thread thread3 = new Thread(priorityDemo, &quot;c&quot;);        Thread thread4 = new Thread(priorityDemo, &quot;d&quot;);        Thread thread5 = new Thread(priorityDemo, &quot;e&quot;);        Thread thread6 = new Thread(priorityDemo, &quot;f&quot;);\t\t//设置优先级        thread1.setPriority(Thread.MAX_PRIORITY);        thread1.start();        thread2.setPriority(7);        thread2.start();        thread3.setPriority(6);        thread3.start();        thread4.setPriority(5);        thread4.start();        thread5.setPriority(4);        thread5.start();        thread6.setPriority(3);        thread6.start();    &#125;&#125;/*输出结果main--&gt;5e--&gt;4a--&gt;10d--&gt;5c--&gt;6b--&gt;7f--&gt;3*/\n\n守护线程public class Daemon &#123;    public static void main(String[] args) &#123;        DaemonThread daemonThread = new DaemonThread();        UserThread userThread = new UserThread();        Thread thread = new Thread(daemonThread);        //设置守护线程        thread.setDaemon(true);        thread.start();        new Thread(userThread).start();    &#125;&#125;class DaemonThread implements Runnable &#123;    @Override    public void run() &#123;        while (true) &#123;            try &#123;                Thread.sleep(2000);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            System.out.println(&quot;Daemon thread running&quot;);        &#125;    &#125;&#125;class UserThread implements Runnable &#123;    @Override    public void run() &#123;        int k = 10;        while (k &gt; 0) &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            System.out.println(k + &quot;-user thread running&quot;);            k--;        &#125;    &#125;&#125;/*输出结果10-user thread runningDaemon thread running9-user thread running8-user thread runningDaemon thread running7-user thread running6-user thread runningDaemon thread running5-user thread running4-user thread runningDaemon thread running3-user thread running2-user thread runningDaemon thread running1-user thread running/*\n\n线程同步！多个线程访问同一个对象，并且某些线程还想修改这个对象，此时需要线程同步，线程同步是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程在使用\n形成条件：队列 + 锁\n锁的是共享的对象\n//买票问题解决public class ThreadDemo implements Runnable &#123;    private int ticketNum = 10;    boolean flag = true;    @Override    public void run() &#123;        while (flag) &#123;            try &#123;                buy();                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    //添加synchronized表明是同步方法    private synchronized void buy()&#123;        if(ticketNum &lt;= 0)&#123;            flag = false;            return;        &#125;        System.out.println(Thread.currentThread().getName() + &quot;--&gt; 拿到了第&quot; + ticketNum-- + &quot;张票&quot;);    &#125;    public static void main(String[] args) &#123;        ThreadDemo ticket = new ThreadDemo();        new Thread(ticket, &quot;张三&quot;).start();        new Thread(ticket, &quot;李四&quot;).start();        new Thread(ticket, &quot;黄牛&quot;).start();    &#125;&#125;\n\n死锁多个线程互相占有着对方需要的资源，形成死锁\npublic class DeadLock &#123;    public static void main(String[] args) &#123;        Occupy personA = new Occupy(&quot;a&quot;);        Occupy personB = new Occupy(&quot;b&quot;);        new Thread(personA, &quot;a&quot;).start();        new Thread(personB, &quot;b&quot;).start();    &#125;&#125;class goodA &#123; &#125;class goodB &#123; &#125;class Occupy implements Runnable&#123;    static goodA goodA = new goodA();    static goodB goodB = new goodB();    private String Name;    Occupy(String Name)&#123;        this.Name = Name;    &#125;    @Override    public void run() &#123;        try &#123;            holds();        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    private void holds() throws InterruptedException &#123;        //代码中，a占据A物品后，休眠3s，在这期间b拿到物品B进入休眠，a休眠结束后物品A已经被B占据，b休眠结束后物品A已被a占据，此时双方都无法拿到另一个物品，造成死锁        if (Name == &quot;a&quot;) &#123;            synchronized (goodA) &#123;                System.out.println(Thread.currentThread().getName() + &quot;占有了&quot; + &quot;物品A&quot;);                Thread.sleep(3000);                synchronized (goodB) &#123;                    System.out.println(Thread.currentThread().getName() + &quot;占有了&quot; + &quot;物品B&quot;);                &#125;            &#125;        &#125; else &#123;            synchronized (goodB) &#123;                System.out.println(Thread.currentThread().getName() + &quot;占有了&quot; + &quot;物品B&quot;);                Thread.sleep(3000);                synchronized (goodA) &#123;                    System.out.println(Thread.currentThread().getName() + &quot;占有了&quot; + &quot;物品A&quot;);                &#125;            &#125;        &#125;    &#125;&#125;\n\n产生死锁的四个必要条件\n\n互斥条件：一个资源每次只能被一个进程使用\n请求与保持条件：一个进程因请求资源而阻塞时，对方获得的资源保持不放\n不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺\n循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系\n\n","categories":["java"],"tags":["java多线程"]},{"title":"分割链表","url":"/2023/02/11/%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/","content":"Leetcode-86分割链表可以看作是快排链表的简化版本\n\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* partition(ListNode* head, int x) &#123;        auto small = new ListNode(-1);        auto large = new ListNode(-1);        auto l = small, r = large;        while(head)&#123;            if(head -&gt; val &lt; x)&#123;                small -&gt; next = head;                small = small -&gt; next;            &#125;else&#123;                large -&gt; next = head;                large= large -&gt; next;            &#125;            head = head -&gt; next;        &#125;        large -&gt; next = NULL;        small -&gt; next = r -&gt; next;        return l -&gt; next;    &#125;&#125;;","categories":["刷题日记"],"tags":["刷题日记"]},{"title":"剑指offer30.包含min函数的栈","url":"/2023/02/12/%E5%89%91%E6%8C%87offer30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","content":"定义存放最小数的辅助栈，元素顺序与主栈一致\n\nclass MinStack &#123;    stack&lt;int&gt; x_stack;    stack&lt;int&gt; min_stack;public:    MinStack() &#123;        min_stack.push(INT_MAX);    &#125;        void push(int x) &#123;        x_stack.push(x);        min_stack.push(::min(min_stack.top(), x));    &#125;        void pop() &#123;        x_stack.pop();        min_stack.pop();    &#125;        int top() &#123;        return x_stack.top();    &#125;        int min() &#123;        return min_stack.top();    &#125;&#125;;","categories":["刷题日记"],"tags":["刷题日记"]},{"title":"回溯","url":"/2023/02/20/%E5%9B%9E%E6%BA%AF/","content":"回溯算法常用来处理组合，切割，排列等问题\n\n回溯模板func back(/*参数*/)&#123;    if /*条件*/ &#123;        //到底了，收集结果        return    &#125;    for &#123;        //处理节点        //递归        //回溯操作    &#125;&#125;","categories":["基础算法复习"],"tags":["算法"]},{"title":"二叉树路径问题","url":"/2023/02/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/","content":"在lc中，经常会遇到二叉树路径问题，此类问题一般使用DFS求解\n\n自顶向下一般路径\nvector&lt;vector&lt;int&gt;&gt;res;void dfs(TreeNode*root,vector&lt;int&gt;path)&#123;    if(!root) return;  //根节点为空直接返回    path.push_back(root-&gt;val);  //作出选择    if(!root-&gt;left &amp;&amp; !root-&gt;right) //如果到叶节点      &#123;        res.push_back(path);        return;    &#125;    dfs(root-&gt;left,path);  //继续递归    dfs(root-&gt;right,path);&#125;\n给定和的路径\nvoid dfs(TreeNode*root, int sum, vector&lt;int&gt; path)&#123;    if (!root)        return;    sum -= root-&gt;val;    path.push_back(root-&gt;val);    if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == 0) //和为0代表找到了等于和的路径    &#123;        res.push_back(path); //路径push进结果        return;    &#125;    dfs(root-&gt;left, sum, path);    dfs(root-&gt;right, sum, path);&#125;\n\n例题路径总和二\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;    public:    vector&lt;vector&lt;int&gt;&gt; res; //结果集    void dfs(TreeNode* root, int sum, vector&lt;int&gt; path)&#123;        if(!root) return;        sum -= root -&gt; val;        path.push_back(root -&gt; val);        //判定叶子节点与和是否相等两个条件        if(!root -&gt; left &amp;&amp; !root -&gt; right &amp;&amp; sum == 0)&#123;            res.push_back(path);            return;        &#125;        dfs(root -&gt; left, sum, path);        dfs(root -&gt; right, sum, path);    &#125;        vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;        vector&lt;int&gt; path;        dfs(root, targetSum, path);        return res;    &#125;&#125;;\n路径总和三\nclass Solution &#123;public:    int rootSum(TreeNode* root, long targetSum) &#123;        if (!root) &#123;            return 0;        &#125;        int ret = 0;        if (root-&gt;val == targetSum) &#123;            ret++;        &#125;         //由于可以不在根节点开始，因此需要递归左右节点        ret += rootSum(root-&gt;left, targetSum - root-&gt;val);        ret += rootSum(root-&gt;right, targetSum - root-&gt;val);        return ret;    &#125;    int pathSum(TreeNode* root, int targetSum) &#123;        if (!root) &#123;            return 0;        &#125;                int ret = rootSum(root, targetSum);        ret += pathSum(root-&gt;left, targetSum);        ret += pathSum(root-&gt;right, targetSum);        return ret;    &#125;&#125;;\n从叶节点开始的最小字符串\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;string&gt; path;    string smallestFromLeaf(TreeNode* root) &#123;        dfs(root, &quot;&quot;);        sort(path.begin(), path.end());        return path[0];    &#125;        void dfs(TreeNode* root, string s)&#123;        if(!root) return;        s += &#x27;a&#x27; + root -&gt; val;        if(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;            reverse(s.begin(), s.end());            path.push_back(s);        &#125;        dfs(root -&gt; left, s);        dfs(root -&gt; right, s);    &#125;&#125;;\n\n非自顶向下二叉树中最大路径和\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    int res = INT_MIN;    int dfs(TreeNode* root)&#123;        if(!root) return 0;        int left = max(dfs(root -&gt; left), 0);        int right = max(dfs(root -&gt; right), 0);        res = max(res, left + right + root -&gt; val);        return max(left + root -&gt; val, right + root -&gt; val);    &#125;        int maxPathSum(TreeNode* root) &#123;        dfs(root);        return res;    &#125;&#125;;","categories":["刷题日记"],"tags":["刷题日记"]},{"title":"失败经历","url":"/2023/02/10/%E5%A4%B1%E8%B4%A5%E7%BB%8F%E5%8E%86/","content":"刚去自习室的前几天，就注意到了隔座的女生，不知为何，看到她的第一眼就有种说不出的感觉。纠结了许久，终于在前天女生晚上回家后，在她的桌子上留下了要联系方式的纸条。一晚忐忑后，第二天无事发生，蛮想再争取一下，但想到会打扰到女生，思虑再三还是放弃了。就在今天，终于收到了女生的回复：\n谢谢抱歉也祝你早日上岸\n看到内容后说不上难过，也许女生早有所属，也许现阶段没有认识一个陌生人的精力罢了。萍水相逢，几天后便成了陌生人，难免会有些遗憾。想起上次有这种感觉还是在六年前，不知道下次是什么时候。只希望我的纸条能给女生平淡的备考期带来一丝惊喜吧 ~\n\n\n","categories":["日记"],"tags":["杂语"]},{"title":"堆","url":"/2023/02/09/%E5%A0%86/","content":"堆小根堆下标在1开始每一个点都小于等于左右子节点\n\n树的一位数组存储方式：索引为x的节点，左子节点为2x，右子节点为2x+1\n插入一个元素：在树的最后一个元素后插入，然后根据大小向上移动，heap[++size] = x; up(size)\n堆中的最小值：heap[1]\n堆中删除最小值：先使用最后一个点覆盖掉头节点，再把尾节点删掉，最后下沉头节点heap[1] = heap[size]; size—-; down(1)\n堆中删除任意一个元素：heap[k] = heap[size]; size—-，再根据k位元素变大还是变小使用down(k)或者up(k)\n堆中修改任意一个元素：heap[x] = k;在down(x)或者up(x)\n\n堆排序\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int h[N], cnt;//up操作void up(int u)&#123;    while(u / 2 &amp;&amp; h[u / 2] &lt; h[u]) &#123;        swap(h[u / 2], h[u]);        u /= 2;    &#125;&#125;void down(int u)&#123;    int t = u;    if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;    if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;    if (u != t)    &#123;        swap(h[u], h[t]);        down(t);    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]);    cnt = n;    for (int i = n / 2; i; i -- ) down(i);    while (m -- )    &#123;        printf(&quot;%d &quot;, h[1]);        h[1] = h[cnt -- ];        down(1);    &#125;    puts(&quot;&quot;);    return 0;&#125;\n当需要操作堆中第k个元素时，要加入映射关系acwing模拟堆：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;const int N = 100010;int h[N], ph[N], hp[N], cnt;void heap_swap(int a, int b)&#123;    swap(ph[hp[a]],ph[hp[b]]);    swap(hp[a], hp[b]);    swap(h[a], h[b]);&#125;void down(int u)&#123;    int t = u;    if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;    if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;    if (u != t)    &#123;        heap_swap(u, t);        down(t);    &#125;&#125;void up(int u)&#123;    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])    &#123;        heap_swap(u, u / 2);        u &gt;&gt;= 1;    &#125;&#125;int main()&#123;    int n, m = 0;    scanf(&quot;%d&quot;, &amp;n);    while (n -- )    &#123;        char op[5];        int k, x;        scanf(&quot;%s&quot;, op);        if (!strcmp(op, &quot;I&quot;))        &#123;            scanf(&quot;%d&quot;, &amp;x);            cnt ++ ;            m ++ ;            ph[m] = cnt, hp[cnt] = m;            h[cnt] = x;            up(cnt);        &#125;        else if (!strcmp(op, &quot;PM&quot;)) printf(&quot;%d\\n&quot;, h[1]);        else if (!strcmp(op, &quot;DM&quot;))        &#123;            heap_swap(1, cnt);            cnt -- ;            down(1);        &#125;        else if (!strcmp(op, &quot;D&quot;))        &#123;            scanf(&quot;%d&quot;, &amp;k);            k = ph[k];            heap_swap(k, cnt);            cnt -- ;            up(k);            down(k);        &#125;        else        &#123;            scanf(&quot;%d%d&quot;, &amp;k, &amp;x);            k = ph[k];            h[k] = x;            up(k);            down(k);        &#125;    &#125;    return 0;&#125;","categories":["基础算法复习"],"tags":["算法"]},{"title":"哈希","url":"/2023/02/09/%E5%93%88%E5%B8%8C/","content":"哈希在题目中通常使用Map容器和Set容器来进行哈希操作，哈希的实现主要有两种，分别是拉链法和开放寻址法（蹲坑法？）\n拉链法对于数x，使用某个质数令x取模后，把余数作为下标存储，发生哈希冲突时，将发生冲突的数像链表一样接到发生冲突的数后面。\n模拟散列表：\n#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 100003;int h[N], e[N], ne[N], idx;void insert(int x)&#123;    int k = (x % N + N) % N;    e[idx] = x;    ne[idx] = h[k];    h[k] = idx ++ ;&#125;bool find(int x)&#123;    int k = (x % N + N) % N;    for (int i = h[k]; i != -1; i = ne[i])        if (e[i] == x)            return true;    return false;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    memset(h, -1, sizeof h);    while (n -- )    &#123;        char op[2];        int x;        scanf(&quot;%s%d&quot;, op, &amp;x);        if (*op == &#x27;I&#x27;) insert(x);        else        &#123;            if (find(x)) puts(&quot;Yes&quot;);            else puts(&quot;No&quot;);        &#125;    &#125;    return 0;&#125;\n\n开放寻址法\n#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 200003, null = 0x3f3f3f3f;int h[N];int find(int x)&#123;    int t = (x % N + N) % N;    while (h[t] != null &amp;&amp; h[t] != x)    &#123;        t ++ ;        if (t == N) t = 0;    &#125;    return t;&#125;int main()&#123;    memset(h, 0x3f, sizeof h);    int n;    scanf(&quot;%d&quot;, &amp;n);    while (n -- )    &#123;        char op[2];        int x;        scanf(&quot;%s%d&quot;, op, &amp;x);        if (*op == &#x27;I&#x27;) h[find(x)] = x;        else        &#123;            if (h[find(x)] == null) puts(&quot;No&quot;);            else puts(&quot;Yes&quot;);        &#125;    &#125;    return 0;&#125;\n\n字符串哈希acwing题目：字符串哈希\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ULL;const int N = 100010, P = 131;int n, m;char str[N];ULL h[N], p[N];ULL get(int l, int r)&#123;    return h[r] - h[l - 1] * p[r - l + 1];&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    scanf(&quot;%s&quot;, str + 1);    p[0] = 1;    for (int i = 1; i &lt;= n; i ++ )    &#123;        h[i] = h[i - 1] * P + str[i];        p[i] = p[i - 1] * P;    &#125;    while (m -- )    &#123;        int l1, r1, l2, r2;        scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);        if (get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;);        else puts(&quot;No&quot;);    &#125;    return 0;&#125;","categories":["基础算法复习"],"tags":["算法"]},{"title":"寄！","url":"/2023/02/09/%E6%80%82/","content":"记录今天，给女生要联系方式失败了，我太怂了啊啊啊！！！\n","categories":["日记"],"tags":["杂语"]},{"title":"留言板","url":"/2023/02/09/%E7%95%99%E8%A8%80%E6%9D%BF/","content":"快来留言吧 ~\n","categories":["留言板"]},{"title":"排序链表","url":"/2023/02/11/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/","content":"Leetcode-148起初想要用快排，但lc给的用例太恶心了，总是会超时。快排代码：\n\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* gettail(ListNode* head)&#123;        while(head -&gt; next) head = head -&gt; next;        return head;    &#125;        ListNode* sortList(ListNode* head) &#123;        if(!head || !head -&gt; next) return head;        auto left = new ListNode(-1), mid = new ListNode(-1), right = new ListNode(-1);        auto ltail = left, mtail = mid, rtail = right;        int val = head -&gt; val;        for(auto p = head; p; p = p -&gt; next)&#123;            if(p -&gt; val &lt; val) ltail = ltail -&gt; next = p;            else if(p -&gt; val == val) mtail = mtail -&gt; next = p;            else rtail = rtail -&gt; next = p;        &#125;        ltail -&gt; next = mtail -&gt; next = rtail -&gt; next = NULL;        left -&gt; next = sortList(left -&gt; next);        right -&gt; next = sortList(right -&gt; next);                gettail(left) -&gt; next = mid -&gt; next;        gettail(left) -&gt; next = right -&gt; next;                auto p = left -&gt; next;        delete left;        delete mid;        delete right;        return p;    &#125;&#125;;\n最后使用归并来解决问题\nclass Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        if (!head || !head-&gt;next) return head;        auto slow = head, fast = head;        while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)            slow = slow-&gt;next, fast = fast-&gt;next-&gt;next;        fast = slow-&gt;next, slow-&gt;next = nullptr;        return merge(sortList(head), sortList(fast));    &#125;private:    ListNode* merge(ListNode* l1, ListNode* l2) &#123;        ListNode sub(0), *ptr = &amp;sub;        while (l1 &amp;&amp; l2) &#123;            auto &amp;node = l1-&gt;val &lt; l2-&gt;val ? l1 : l2;            ptr = ptr-&gt;next = node, node = node-&gt;next;        &#125;        ptr-&gt;next = l1 ? l1 : l2;        return sub.next;    &#125;&#125;;","categories":["刷题日记"],"tags":["刷题日记"]},{"title":"快排-归并-二分","url":"/2023/01/30/%E5%BF%AB%E6%8E%92-%E5%BD%92%E5%B9%B6-%E4%BA%8C%E5%88%86/","content":"快速排序\n确定分界点x，通常选取左端点，中间值或右端点\n调整区间，使得左区间都小于等于x，右区间都大于等于x\n递归处理左右两段调整区间的思路：当 q[i] &lt; x 或者 q[j] &gt; x时，双指针不停向中间移动，当两者都不满足条件，且i &lt; j时，交换值void quick_sort(int q[], int l, int r)&#123;    if(l &gt;= r) return;    int x = q[(l + r) / 2], I = l - 1, j = r + 1;    while(i &lt; j)&#123;        do i++; while(q[i] &lt; x);        do j—-; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);     &#125;    quick_sort(q, l, j);    quick_sort(q, j+1, r);&#125; \n\n归并排序\n选取中间点mid = （1 + r） / 2\n递归左右两区间，得到单调递增的左右区间\n归并左右两区间归并区间的思路：开辟新数组tmp，双指针i, j 分别指向两个区间的端点，将i, j指针指向较小的数放入tmp，当某段区间结束时，将另一段区间剩余的数直接接到ans数组最后。void merge_sort(int q[], int l, int r)&#123;    if(l &lt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);    int i = l, j = mid + 1, k = 0;    while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;        if(q[i] &lt;= q[j]) tmp[k++] = q[i++];        else tmp[k++] = q[j++];    &#125;    while(l &lt;= mid) tmp[k++] = q[i++];    while(j &lt;= r) tmp[k++] = q[j++];    for(i = l, j = 0; i &lt; r; i++, j++) q[i] = tmp[j];&#125;\n\n整数二分取中间值时需要注意，如果r = mid则中值取l + r &gt;&gt; 1，如果是l = mid则中值取l + r + 1 &gt;&gt;1题目示例：数的范围给定一个按照升序排列的长度为n的整数数组，以及q个查询。对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。如果数组中不存在该元素，则返回-1 -1。\nint main()&#123;    while(queryCount—-)&#123;        int l = 0, r = n - 1;        while(l &lt; r)&#123;            int mid = l + r &gt;&gt; 1;            if(q[mid] &gt;= x) r = mid;            else l = mid + 1;         &#125;        if(q[l] != x) cout &lt;&lt; “-1 -1” &lt;&lt; endl;        else &#123;            cout &lt;&lt; l &lt;&lt; “ ”;            int l = 0; r = n - 1;             while(l &lt; r)&#123;                int mid = l + r + 1 &gt;&gt; 1;                if(q[mid] &lt;= x) l = mid;                else r = mid - 1;            &#125;            cout &lt;&lt; l &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;\n\n浮点数二分int main()&#123;    double l = 0, r = x;    while(r - 1 &gt; 1e-6)&#123;        double mid = (l + r) / 2;        if(mid * mid &gt;= x) r = mid;        else l = mid;        &#125;    cout &lt;&lt; l;&#125;\n","categories":["基础算法复习"],"tags":["算法"]},{"title":"高精度-前缀和-差分","url":"/2023/02/09/%E9%AB%98%E7%B2%BE%E5%BA%A6-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/","content":"高精度大整数存储：使用数组存取大整数，由于在数组的末尾添加值要比在开头添加容易，因此数组的0位一般存取大整数的个位。高精度在很多需要求补位的题目中会遇到，详情见Leetcode。高精度加法：代码中使用k表示进位，每次循环计算两数相加结果和k\n\nvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size() || i &lt; B.size(); i++)&#123;        //A + B结果存到t中        if(i &lt; A.size()) t += A[i];        if(i &lt; B.size()) t += B[i];                //个位存到C中        C.push_back(t % 10);                //如果t &gt; 10, t取进位        t /= 10;    &#125;    if(t) C.push_back(t);    return C;&#125;\n\n高精度减法：\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size() || i &lt; B.size(); i++)&#123;        //t 等于被减数减去借位        t = A[i] - t;        if(i &lt; B.size()) t -= B[i];        C.push_back((t + 10) % 10);                //如果 t &lt; 0 证明存在借位        if(t &lt; 0) t = 1;        else t = 0;    &#125;    //把结果前面的0去掉    while(C.size() &gt; 1 &amp;&amp; c.back() == 0) C.pop_back();    return C;&#125;\n高精度乘法：\nvector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, b)&#123;    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size() || t; i++)&#123;        if(i &lt; A.size()) t += A[i] * b;        C.push_back(t % 10);        t /= 10;    &#125;    return 10;&#125;\n高精度除法：\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123;    vector&lt;int&gt; C;    r = 0;    for(int i = A.size() - 1; i &gt;= 0; i ++)&#123;        r = r * 10 + A[i];        C.push_back(r / b);        r %= b;    &#125;    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;&#125;\n\n前缀和for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];for(int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i];\n差分差分为前缀和的逆运算，假设存在a[], b[]，使得a[i] = b[1] + b[2] + … + b[i]，构造方法为b[i] = a[i] - a[i - 1]\n","categories":["基础算法复习"],"tags":["算法"]},{"title":"树-图","url":"/2023/02/09/%E6%A0%91-%E5%9B%BE/","content":"树和图的存储有向图的存储方式有：\n\n邻接矩阵（不常用）\n邻接表（常用）：每个点都是一个单链表图和树的遍历方式同样是深度优先遍历和广度优先遍历深度优先遍历代码中，h数组表示每个点，ne表示该点下一个点的索引，e表示所有的边，idx表示当前点的索引。#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 100010, M = 2 * N;int h[N], e[M], ne[N], idx;bool st[N];void dfs(int u)&#123;    //表示当前点已经遍历过了    st[u] = true;    for(int i = h[u]; i != -1; i = ne[i])&#123;        int j = e[i];        if(!st[u]) dfs(j);    &#125;&#125;int main()&#123;    memset(h, -1, sizeof h);    dfs(1);&#125;\n拓扑序列所有起点有指向终点，有向无环图一定存在拓扑序列入度与出度对于某个点而言，所有指向该点的边的值，叫做该点的入度，反之叫做该点的出度。\n\n","categories":["基础算法复习"],"tags":["算法"]},{"title":"链表-栈-队列","url":"/2023/02/09/%E9%93%BE%E8%A1%A8-%E6%A0%88-%E9%98%9F%E5%88%97/","content":"数组模拟静态链表使用数组模拟静态链表速度要显著快于使用结构体。\n\n代码中head表示头节点指向的位置，e[N]表示该节点的值，ne[N]表示节点指向的下一个节点的索引，idx表示当前节点的索引，代码中展示了三种链表的基本操作，分别是头节点插入，任意节点插入，与删除。\n#include&lt;iostream&gt;using namespace std;const N = 100010;int head, e[N], ne[N], idx; void init()&#123;    head = -1;    idx = 0;&#125;//在头节点插入void add_to_head(int x) &#123;    e[idx] = x;    ne[idx] = head;    head = idx;    idx++;&#125;//插入到k下标后void insert_k(int k, int x)&#123;    e[idx] = x;    ne[idx] = ne[k];    ne[k] = idx;    idx++&#125;//删除下标为k的点的后面的点void remove_k(int k)&#123;    ne[k] = ne[ne[k]];&#125;int main() &#123;    &#125;\n\n双向链表\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int e[N], l[N], r[N]void init()&#123;    r[0] = 1, l[1] = 0;    idx = 2;&#125;//在k的右边插入一个节点，当想要在k的左边插入节点时，可以写add(l[k], x)void add(int k, int x) &#123;    e[idx] = x;    l[idx] = k;    r[idx] = r[k];    l[r[k]] = idx;    r[k] = idx;    &#125;void remove(int k) &#123;    r[l[k]] = r[k];    l[r[k]] = l[k];&#125;int main()\n\n栈和队列\n#include&lt;iostream&gt;using namespace std;int stk[N], tt;//插入stk[++ tt] = x;//弹出tt—-//判断栈是否为空if(tt &gt; 0) not emptyelse empty栈顶stk[tt]//**********＊***********//队列int q[N], hh, tt//插入q[++tt] = x;//弹出hh++;//判断空if(hh &lt; tt) not emptyelse empty//取出队头元素q[hh]\n\n单调栈例题：找出数组中每个元素左边距离他最近且比他小的元素，没有返回-1思路：如果存在a[x] &lt; a[y] &amp;&amp; x &gt; y那a[y]永远都不会被输出出来，如此一来，可以直接在栈顶往下找，找到后吧新值入栈\n#include&lt;iostream&gt;using namespace std;const int N = 100010int n;int stk[N], tt;int main()&#123;    cin &gt;&gt; n;    for(int i = 0; i &lt; n; i++) &#123;        int x;        cin &gt;&gt; x;        while(tt &amp;&amp; stk[tt] &gt;= x) tt—-;        if(tt) cout &lt;&lt; stk[tt] &lt;&lt; “ ”;        else cout &lt;&lt; -1 &lt;&lt; “ ”;        stk[++t] = x;         &#125;    return 0;   &#125;\n\n\n单调队列滑动窗口问题\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int n, k;int a[N], q[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; k;    for(int i = 0; i &lt; n; i++ ) &#123;        if(hh &lt;= tt &amp;&amp; i - k +1 &gt; q[hh]) h++;        while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) t—-;        q[++t] = i;        if(i &gt;= k - 1) cout &lt;&lt; a[q[hh]];        puts(“”);    &#125;    puts(“”);        hh = 0, tt = -i;    for(int i = 0; i &lt; n; i++) &#123;        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++;        while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) t—-;        q[++t] = i;        if(i &gt;= k - 1) cout &lt;&lt; a[q[hh]];    &#125;    puts(“”);&#125;","categories":["基础算法复习"],"tags":["算法"]}]