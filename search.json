[{"title":"2023-1-30Go基础复习","url":"/2023/01/30/2023-1-30Go%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/","content":"切片在Go中，一般使用切片替代数组的使用，Go认为数组长度属于其类型的一部分，这可能导致[3]int的数组类型不同于定义为[4]int的类型，也意味着不能使用变量去指定数组长度，因为变量必须在编译时而不是在运行时解析。\n切片的定义：\n\n带字面量：var x = []int&#123;1, 2, 3&#125;\n不带字面量：var x []int，不带字面量时，由于切片没有被赋值，因此切片x被赋予零值nil\n\n切片中常用方法:\n\n切片长度len()，len(x)\n增加元素append()，可以添加单个值：x = append(x, 10)，也可以添加多个值x = append(x, 1, 2, 3, 4)，或者使用…操作符添加切片：x = append(x, y…)\n\n容量：切片是一个数值序列，切片中的值占用内存中的连续地址，切片在连续内存地址的大小就是切片的容量。容量可能会大于切片的长度，当最终所需长度超出容量的大小时，append函数使用Go运行时分配一个有更大容量的切片，将原切片的内容拷贝到新切片，将需要添加的值添加到新切片的末尾，并返回新切片。使用cap函数可以得到切片的容量。代码示例：\nvar x []intfat.Println(x, len(x), cap(x))x = append(x, 10)fat.Println(x, len(x), cap(x))x = append(x, 20)fat.Println(x, len(x), cap(x))x = append(x, 30)fat.Println(x, len(x), cap(x))x = append(x, 40)fat.Println(x, len(x), cap(x))x = append(x, 50)fat.Println(x, len(x), cap(x))answer:[] 0 0[10] 1 1[10 20] 2 2[10 20 30] 3 4[10 20 30 40] 4 4[10 20 30 40 50] 5 8\n在Go中，可以通过make函数创建所需容量的切片。x := make([]int, 5)，此时会创建一个长度为5，容量为5的整型切片。使用make创建切片后，不可以再使用append添加初始元素，如使用x = append(x, 10)，此时10会被添加至切片尾部，切片的容量会再增加一倍。可以指定切片的容量：x := make([]int, 5, 10)，此时创建了一个长度为5，容量为10的切片。也可以创建长度为0的切片，x := make([]int, 0, 5)，此时可以通过append方法向切片内追加数据。\n派生切片：在切片内使用:来生成派生切片。\nx := []int&#123;1, 2, 3, 4&#125;y := x[:2]fmt.Println(y)answer:[1 2]\n切片有时会共享内存，子切片的容量是原切片的容量减去切片的偏移量，因此，原切片为使用容量会和子切片共享。当改变x切片时，y也会随之改变。\n字符串，字符和字节参照切片，字符串同样有派生表达式来获取子串\nMap创建零值映射：var nilMap map[string]int创建字面量映射：totalMap := map[string]int&#123;&#125;\nMap的读写操作：\ndemoMap := map[string]int&#123;&#125;demoMap[“Amy”] = 98demoMap[“Tom”] = 90fmt.Println(demoMap[“Tom”])answer:90\n如果尝试读取Map中不存在的键，会返回0值，为了判断零值是由于该键不存在还是该键与零值相关联，我们可以使用ok模式。\n//接上述代码v, ok := demoMap[“Amy”]fmt.Println(v, ok)answer:98, true\n\ndelete函数可以删除Map中的键值delete(demoMap, “Amy”)\n映射模拟集合：\nintSet = map[int]bool&#123;&#125;vals := []int&#123;1, 3, 3, 5, 2, 9, 8&#125;for _, v := range vals &#123;    intSet[v] = true;&#125;\n因为映射中不会存在相同的键，因此所有相同的值只会被存放一次，当访问不存在的键时，会返回零值，对应bool的false\n结构体常规结构体的定义与访问：\ntype person struct&#123;    name string    age int    sex string&#125;//以下两种方式都会将结构体赋值零值var Tom personAmy := person&#123;&#125;//非空字面量赋值Sam := person&#123;    name: “Sam”,    age: 19,&#125;Tom.name = “Tom”\n匿名结构体：\nvar person struct &#123;    name string    age int    sex string   &#125;\n\n流程控制for - range：\ntmp := []int&#123;3, 4, 5&#125;for i, v := range tmp&#123;    fmt.Println(i, v)&#125;answer:0 31 42 5\n当不需要获取索引时，可以使用_来代替\n在嵌套循环中，可以使用outer标签跳出最外层循环\n","categories":["Go基础复习"],"tags":["Go"]},{"title":"第一篇博客","url":"/2023/01/23/first-post/","content":"折腾了许久，终于完成的自己的博客。\n建站之初，计划使用 React + Gin 进行博客的搭建，但最终还是放弃了，自己的审美实在过于糟糕，况且，写前端的时间足够学习很多东西，手撸一个博客对于一名大三在校生而言有些过于浪费时间了。\n最终选用 Hexo 进行博客的搭建，Hexo可以解析 MarkDown 文本，生成静态 HTML 页面，最最最重要的是，Hexo 提供了许多现成的主题，对主题不满意的地方可以直接对 CSS 进行修改，在魔改了两天之后，博客网站的样式终于到了我的审美上。\n博客采用 GitHub Page 进行部署，每一篇文章的更新相当于用 GIT 将代码提交到仓库里，再对仓库的 Custom domain 进行设置，把域名添加到上面，这样就可以直接通过域名对博客进行访问了。\n说到域名，还踩了很多坑，在腾讯云进行域名解析时，可以直接把记录类型设置为 CNAME 之后对 ping 一下仓库的地址，填到记录值上就好了，除此之外要在项目的 Source 文件夹下新建一个CNAME 文件，把域名填到里面，不然每次 commit 都要在仓库里重新绑定域名，离谱的很！\n搭建博客是为了督促自己多学习，多更新技术文章，希望能做到😢\n","categories":["杂语"],"tags":["杂语"]},{"title":"2023-1-30算法基础复习","url":"/2023/01/30/2023-1-30%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/","content":"快速排序\n确定分界点x，通常选取左端点，中间值或右端点\n调整区间，使得左区间都小于等于x，右区间都大于等于x\n递归处理左右两段调整区间的思路：当 q[i] &lt; x 或者 q[j] &gt; x时，双指针不停向中间移动，当两者都不满足条件，且i &lt; j时，交换值void quick_sort(int q[], int l, int r)&#123;    if(l &gt;= r) return;    int x = q[(l + r) / 2], I = l - 1, j = r + 1;    while(i &lt; j)&#123;        do i++; while(q[i] &lt; x);        do j—-; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);     &#125;    quick_sort(q, l, j);    quick_sort(q, j+1, r);&#125; \n\n归并排序\n选取中间点mid = （1 + r） / 2\n递归左右两区间，得到单调递增的左右区间\n归并左右两区间归并区间的思路：开辟新数组tmp，双指针i, j 分别指向两个区间的端点，将i, j指针指向较小的数放入tmp，当某段区间结束时，将另一段区间剩余的数直接接到ans数组最后。void merge_sort(int q[], int l, int r)&#123;    if(l &lt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);    int i = l, j = mid + 1, k = 0;    while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;        if(q[i] &lt;= q[j]) tmp[k++] = q[i++];        else tmp[k++] = q[j++];    &#125;    while(l &lt;= mid) tmp[k++] = q[i++];    while(j &lt;= r) tmp[k++] = q[j++];    for(i = l, j = 0; i &lt; r; i++, j++) q[i] = tmp[j];&#125;\n\n整数二分取中间值时需要注意，如果r = mid则中值取l + r &gt;&gt; 1，如果是l = mid则中值取l + r + 1 &gt;&gt;1题目示例：数的范围给定一个按照升序排列的长度为n的整数数组，以及q个查询。对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。如果数组中不存在该元素，则返回-1 -1。\nint main()&#123;    while(queryCount—-)&#123;        int l = 0, r = n - 1;        while(l &lt; r)&#123;            int mid = l + r &gt;&gt; 1;            if(q[mid] &gt;= x) r = mid;            else l = mid + 1;         &#125;        if(q[l] != x) cout &lt;&lt; “-1 -1” &lt;&lt; endl;        else &#123;            cout &lt;&lt; l &lt;&lt; “ ”;            int l = 0; r = n - 1;             while(l &lt; r)&#123;                int mid = l + r + 1 &gt;&gt; 1;                if(q[mid] &lt;= x) l = mid;                else r = mid - 1;            &#125;            cout &lt;&lt; l &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;\n\n浮点数二分int main()&#123;    double l = 0, r = x;    while(r - 1 &gt; 1e-6)&#123;        double mid = (l + r) / 2;        if(mid * mid &gt;= x) r = mid;        else l = mid;        &#125;    cout &lt;&lt; l;&#125;\n","categories":["基础算法复习"],"tags":["算法"]}]