[{"title":"01背包问题","url":"/2023/02/10/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","content":"今天开始了动态规划的学习，看着y总的闫氏DP分析法，学会了最基础的01背包问题。\n\n01背包问题#include&lt;iostream&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int dp[N][N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];    for(int i = 1; i &lt;= n; i++)&#123;        for(int j = 0; j &lt;= m; j++) &#123;            dp[i][j] = dp[i - 1][j];            if(v[i] &lt;= j) dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]);        &#125;    &#125;        cout&lt;&lt;dp[n][m];&#125;","categories":["基础算法复习"],"tags":["算法"]},{"title":"DFS-BFS","url":"/2023/02/09/DFS-BFS/","content":"深度优先搜索与广度优先搜索通常用于树和图的操作，经典深度优先搜索例题如八皇后问题。\n\n\n深度优先搜索（DFS）从树的头节点开始，自最左树开始向下搜索，到达叶子节点后回溯，直至搜索完毕。leetcode200.岛屿数量\nclass Solution &#123;public:    int dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j) &#123;        //添加递归限定条件        if (i &lt; 0 || j &lt; 0 || i &gt;= grid.size() || j &gt;= grid[0].size() || grid[i][j] == &#x27;0&#x27;) &#123;            return 0;        &#125;        //最重要的一步，递归的过程中，将每一个岛屿的所有点赋值为0        grid[i][j] = &#x27;0&#x27;;        for (int index = 0; index &lt; 4; ++index) &#123;            int next_i = i + di[index];            int next_j = j + dj[index];            df(grid, next_i,next_j);        &#125;        return 1;    &#125;     int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;        int num = 0;        //对每一个节点进行dfs        for (int i = 0; i &lt; grid.size(); ++i) &#123;            for (int j = 0; j &lt; grid[0].size(); ++j) &#123;                num += dfs(grid, i, j);             &#125;        &#125;        return num;    &#125;private:        int di[4] = &#123;-1,0,1,0&#125;;        int dj[4] = &#123;0,1,0,-1&#125;;&#125;;\n例题：acwing 842.排列数字通过递归与回溯的思想实现深度优先搜索\n#include&lt;iostream&gt;using namespace std;const int N = 8;int n, path[N];bool st[N];void dfs(int u)&#123;    //递归终止的条件为最内层循环终止    if(u == n)&#123;         for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, path[i]);        puts(&quot;&quot;);            &#125;;        for(int i = 1; i &lt;= n; i++)&#123;        if(!st[i])&#123;            path[u] = i;            st[i] = true;            dfs(u + 1);            st[i] = false;        &#125;            &#125;&#125;int main()&#123;    cin &gt;&gt; n;    dfs(0);    return 0;&#125;\n\n广度优先搜索（BFS）从头节点开始，搜索每一层的所有节点。acwing迷宫问题\n#include&lt;iostream&gt;#include&lt;cstring&gt;typedef pair&lt;int, int&gt; PIIconst N = 110;//给定高度与宽度int n, m;//存储图int g[N][N];//记录每个点距离起点的距离int d[N][N];int bfs() &#123;    //给图中所有点赋值为-1，-1代表还没走过    memset(d, -1, sizeof d);    queue&lt;PII&gt; q;    //图中第一个点赋值为0，代表起始走到了第一个点    d[0, 0] = 0;    q.push(&#123;0, 0&#125;);    //设置方向    int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;    while(q.size())&#123;        auto t = q.front();        q.pop();                //遍历到达的每个点的四个方向        for(int i = 0; i &lt; 4; i++) &#123;            int x = t.first + dx[i], y = t.second + dy[i];             if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] == 0 &amp;&amp; d[x][y] == -1) &#123;            //d[x][y]等于上一个节点加一            d[x][y] = d[t.first][t.second] + 1;            q.push(&#123;x, y&#125;);        &#125;    &#125;    return d[n - 1][m - 1];&#125;int main()&#123;    for(int i = 0; i &lt; n; i++)        for(int j = 0; j &lt; m; j++)            cin &gt;&gt; g[i][j];    cout &lt;&lt; bfs() &lt;&lt; endl;&#125;","categories":["基础算法复习"],"tags":["算法"]},{"title":"Go数据结构","url":"/2023/01/30/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"切片在Go中，一般使用切片替代数组的使用，Go认为数组长度属于其类型的一部分，这可能导致[3]int的数组类型不同于定义为[4]int的类型，也意味着不能使用变量去指定数组长度，因为变量必须在编译时而不是在运行时解析。\n切片的定义：\n\n带字面量：var x = []int&#123;1, 2, 3&#125;\n不带字面量：var x []int，不带字面量时，由于切片没有被赋值，因此切片x被赋予零值nil\n\n切片中常用方法:\n\n切片长度len()，len(x)\n增加元素append()，可以添加单个值：x = append(x, 10)，也可以添加多个值x = append(x, 1, 2, 3, 4)，或者使用…操作符添加切片：x = append(x, y…)\n\n容量：切片是一个数值序列，切片中的值占用内存中的连续地址，切片在连续内存地址的大小就是切片的容量。容量可能会大于切片的长度，当最终所需长度超出容量的大小时，append函数使用Go运行时分配一个有更大容量的切片，将原切片的内容拷贝到新切片，将需要添加的值添加到新切片的末尾，并返回新切片。使用cap函数可以得到切片的容量。代码示例：\nvar x []intfat.Println(x, len(x), cap(x))x = append(x, 10)fat.Println(x, len(x), cap(x))x = append(x, 20)fat.Println(x, len(x), cap(x))x = append(x, 30)fat.Println(x, len(x), cap(x))x = append(x, 40)fat.Println(x, len(x), cap(x))x = append(x, 50)fat.Println(x, len(x), cap(x))answer:[] 0 0[10] 1 1[10 20] 2 2[10 20 30] 3 4[10 20 30 40] 4 4[10 20 30 40 50] 5 8\n在Go中，可以通过make函数创建所需容量的切片。x := make([]int, 5)，此时会创建一个长度为5，容量为5的整型切片。使用make创建切片后，不可以再使用append添加初始元素，如使用x = append(x, 10)，此时10会被添加至切片尾部，切片的容量会再增加一倍。可以指定切片的容量：x := make([]int, 5, 10)，此时创建了一个长度为5，容量为10的切片。也可以创建长度为0的切片，x := make([]int, 0, 5)，此时可以通过append方法向切片内追加数据。\n派生切片：在切片内使用:来生成派生切片。\nx := []int&#123;1, 2, 3, 4&#125;y := x[:2]fmt.Println(y)answer:[1 2]\n切片有时会共享内存，子切片的容量是原切片的容量减去切片的偏移量，因此，原切片为使用容量会和子切片共享。当改变x切片时，y也会随之改变。\n字符串，字符和字节参照切片，字符串同样有派生表达式来获取子串\nMap创建零值映射：var nilMap map[string]int创建字面量映射：totalMap := map[string]int&#123;&#125;\nMap的读写操作：\ndemoMap := map[string]int&#123;&#125;demoMap[“Amy”] = 98demoMap[“Tom”] = 90fmt.Println(demoMap[“Tom”])answer:90\n如果尝试读取Map中不存在的键，会返回0值，为了判断零值是由于该键不存在还是该键与零值相关联，我们可以使用ok模式。\n//接上述代码v, ok := demoMap[“Amy”]fmt.Println(v, ok)answer:98, true\n\ndelete函数可以删除Map中的键值delete(demoMap, “Amy”)\n映射模拟集合：\nintSet = map[int]bool&#123;&#125;vals := []int&#123;1, 3, 3, 5, 2, 9, 8&#125;for _, v := range vals &#123;    intSet[v] = true;&#125;\n因为映射中不会存在相同的键，因此所有相同的值只会被存放一次，当访问不存在的键时，会返回零值，对应bool的false\n结构体常规结构体的定义与访问：\ntype person struct&#123;    name string    age int    sex string&#125;//以下两种方式都会将结构体赋值零值var Tom personAmy := person&#123;&#125;//非空字面量赋值Sam := person&#123;    name: “Sam”,    age: 19,&#125;Tom.name = “Tom”\n匿名结构体：\nvar person struct &#123;    name string    age int    sex string   &#125;\n\n流程控制for - range：\ntmp := []int&#123;3, 4, 5&#125;for i, v := range tmp&#123;    fmt.Println(i, v)&#125;answer:0 31 42 5\n当不需要获取索引时，可以使用_来代替\n在嵌套循环中，可以使用outer标签跳出最外层循环\n","categories":["Go基础复习"],"tags":["Go"]},{"title":"JUC","url":"/2023/03/04/JUC/","content":"java多线程第二集\n\nLock锁实现买票import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Main &#123;    public static void main(String[] args) &#123;        Ticket ticket = new Ticket();        new Thread(() -&gt; &#123;for(int i = 0; i &lt; 3; i++) ticket.sale();&#125;, &quot;a&quot;).start();        new Thread(() -&gt; &#123;for(int i = 0; i &lt; 6; i++) ticket.sale();&#125;, &quot;b&quot;).start();        new Thread(() -&gt; &#123;for(int i = 0; i &lt; 1; i++) ticket.sale();&#125;, &quot;c&quot;).start();    &#125;&#125;class Ticket &#123;    private int count = 10;    Lock lock = new ReentrantLock(true);    public void sale() &#123;        lock.lock();            try &#123;                if (count &gt; 0)&#123;                    System.out.println(Thread.currentThread().getName() + &quot;买到了第&quot; + count-- + &quot;张票;&quot; );                &#125;            &#125;catch(Exception e)&#123;                e.printStackTrace();            &#125;finally &#123;                lock.unlock();            &#125;    &#125;&#125;/*ans:a买到了第10张票;b买到了第9张票;c买到了第8张票;a买到了第7张票;b买到了第6张票;a买到了第5张票;b买到了第4张票;b买到了第3张票;b买到了第2张票;b买到了第1张票;*/\n\nCondition精准唤醒import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Main &#123;    public static void main(String[] args) &#123;        Test test = new Test();        new Thread(() -&gt; &#123;for(int i = 0; i &lt; 3; i++) test.printA();&#125;, &quot;a&quot;).start();        new Thread(() -&gt; &#123;for(int i = 0; i &lt; 3; i++) test.printB();&#125;, &quot;b&quot;).start();        new Thread(() -&gt; &#123;for(int i = 0; i &lt; 3; i++) test.printC();&#125;, &quot;c&quot;).start();    &#125;&#125;class Test &#123;    Lock lock = new ReentrantLock();    Condition condition1 = lock.newCondition();    Condition condition2 = lock.newCondition();    Condition condition3 = lock.newCondition();    private int num = 1;    public void printA()&#123;        lock.lock();        try &#123;            while(num != 1) condition1.await();            System.out.println(Thread.currentThread().getName() + &quot;获取线程&quot;);            num = 2;            //唤醒2            condition2.signal();        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;finally &#123;            lock.unlock();        &#125;    &#125;    public void printB()&#123;        lock.lock();        try &#123;            while(num != 2) condition2.await();            System.out.println(Thread.currentThread().getName() + &quot;获取线程&quot;);            num = 3;            //唤醒3            condition3.signal();        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;finally &#123;            lock.unlock();        &#125;    &#125;    public void printC()&#123;        lock.lock();        try &#123;            while(num != 3) condition3.await();            System.out.println(Thread.currentThread().getName() + &quot;获取线程&quot;);            num = 1;            //唤醒1            condition1.signal();        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;finally &#123;            lock.unlock();        &#125;    &#125;&#125;\n\n八锁现象给某个实例加锁后，其他线程不能访问该实例的所有同步方法，但非同步方法仍然可以正常访问\n//因为A总是先拿到锁，所以无论如何总是会先print Aimport java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Main &#123;    public static void main(String[] args) &#123;        LockDemo lockDemo = new LockDemo();        new Thread(() -&gt; &#123;lockDemo.printA();&#125;).start();        new Thread(() -&gt; &#123;lockDemo.printB();&#125;).start();    &#125;&#125;class LockDemo &#123;    Lock lock = new ReentrantLock();    public void printA()&#123;        lock.lock();        try&#123;            TimeUnit.SECONDS.sleep(3);            System.out.println(&quot;print A&quot;);        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;finally &#123;            lock.unlock();        &#125;    &#125;    public void printB()&#123;        lock.lock();        try&#123;            System.out.println(&quot;print B&quot;);        &#125;catch(Exception e)&#123;            e.printStackTrace();        &#125;finally &#123;            lock.unlock();        &#125;    &#125;&#125;/*输出print Aprint B*/\n\nCopyOnWriteArrayList// 并发下，ArryList是不安全的import java.util.ArrayList;import java.util.List;import java.util.UUID;public class Main &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList();        for(int i = 1; i &lt; 100; i++)&#123;            new Thread(() -&gt; &#123;                list.add(UUID.randomUUID().toString().substring(0, 5));                System.out.println(list);                &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;//会报错并发修改异常\n\n此时可以使用CopyOnWrite\n\n写入时复制，避免覆盖，造成写入问题\n\n除此之外可以使用Vector，但是Vector，使用了synchronized同步方法，效率不如CopyOnWrite\nimport java.util.*;import java.util.concurrent.CopyOnWriteArrayList;public class Main &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();        for(int i = 1; i &lt; 100; i++)&#123;            new Thread(() -&gt; &#123;                list.add(UUID.randomUUID().toString().substring(0, 5));                System.out.println(list);                &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;\n\nCallable同Runnable的区别\n\n可以有返回值\n可以抛出异常\n方法不同 – call()\n\n常用辅助类\nCountDownLatch\n\n//此时想要六个线程都跑完之后输出end，但此时会先输出end/*endThread-1endThread-5endThread-2endThread-4endThread-0endThread-3end*/import java.util.concurrent.CountDownLatch;public class Main &#123;    public static void main(String[] args) &#123;        CountDownLatch countDownLatch = new CountDownLatch(6);        for(int i = 1; i &lt;= 6; i++)&#123;            new Thread(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + &quot;end&quot;);                countDownLatch.countDown();            &#125;).start();        &#125;                System.out.println(&quot;end&quot;);    &#125;&#125;//添加countDownLatch.await()/*Thread-3endThread-1endThread-4endThread-2endThread-5endThread-0endend*/import java.util.concurrent.CountDownLatch;public class Main &#123;    public static void main(String[] args) throws InterruptedException &#123;        CountDownLatch countDownLatch = new CountDownLatch(6);        for(int i = 1; i &lt;= 6; i++)&#123;            new Thread(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + &quot;end&quot;);                //数量 -1                countDownLatch.countDown();            &#125;).start();        &#125;        //等待计数器归零再向下执行        countDownLatch.await();        System.out.println(&quot;end&quot;);    &#125;&#125;\n\n\nCycliicBarrier\n\n//同countDownLatch相反，调用await等待，达到线程数量后执行countDownLatch构造器中的线程import java.util.concurrent.CyclicBarrier;public class Main &#123;    public static void main(String[] args) &#123;        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; &#123;           System.out.println(&quot;end&quot;);        &#125;);        for(int i = 1; i &lt;= 7; i++)&#123;            new Thread(() -&gt; &#123;                System.out.println(Thread.currentThread().getName() + &quot;end&quot;);                try &#123;                    cyclicBarrier.await();                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125; catch (BrokenBarrierException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;).start();        &#125;    &#125;&#125;\n\n\nSemaphore\n\nsemaphore.acquire()：获取，如果满，等待到释放为止\n\nsemaphore.release()：释放，当前信号量释放加一，然后唤醒其他等待线程\n\n\n/*输出结果6得到线程2得到线程1得到线程2释放线程1释放线程6释放线程3得到线程5得到线程4得到线程5释放线程3释放线程4释放线程*/import java.util.concurrent.*;public class Main &#123;    public static void main(String[] args) &#123;        //三个线程的数量        Semaphore semaphore = new Semaphore(3);        for(int i = 1; i &lt;= 6; i++)&#123;            new Thread(() -&gt; &#123;                try &#123;                    semaphore.acquire();                    System.out.println(Thread.currentThread().getName() + &quot;得到线程&quot;);                    TimeUnit.SECONDS.sleep(3);                    System.out.println(Thread.currentThread().getName() + &quot;释放线程&quot;);                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;finally &#123;                    semaphore.release();                &#125;            &#125;, String.valueOf(i).toString()).start();        &#125;    &#125;&#125;\n\n读写锁可以被多个线程同时读，但写的时候只能一个线程来写\n/*线程4正在写入key：4线程4写入成功线程2正在写入key：2线程2写入成功线程1正在写入key：1线程1写入成功线程5正在写入key：5线程5写入成功线程3正在写入key：3线程3写入成功*/import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;public class Main &#123;    public static void main(String[] args) &#123;        ReadWriteLockDemo readWriteLockDemo = new ReadWriteLockDemo();        //读取        for(int i = 1; i &lt;= 5; i++)&#123;            int finalI = i;            new Thread(() -&gt; &#123;                readWriteLockDemo.push(finalI, &quot;value&quot; + finalI);            &#125;,String.valueOf(i).toString()).start();        &#125;        for(int i = 1; i &lt;= 5; i++)&#123;            int finalI = i;            new Thread(() -&gt; &#123;                readWriteLockDemo.get(finalI);            &#125;,String.valueOf(i).toString()).start();        &#125;    &#125;&#125;//自定义缓存，实现读和写的操作class ReadWriteLockDemo &#123;    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();    public volatile Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();    public void push(int key, String value)&#123;        readWriteLock.writeLock().lock();        try &#123;            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;正在写入key：&quot; + key);            map.put(key, value);            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;写入成功&quot;);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;finally &#123;            readWriteLock.writeLock().unlock();        &#125;    &#125;    public void get(int key)&#123;        //写加锁是防止读的时候有写的操作        readWriteLock.readLock().lock();        try &#123;            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;正在读取key：&quot; + key);            String res = map.get(key);            System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;读取成功&quot;);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;finally &#123;            readWriteLock.readLock().unlock();        &#125;    &#125;&#125;\n\n线程池池化技术：事先准备好一些资源，有人要用，就来拿，用完还回来\n//三个创建线程池的方式Executors.newSingleThreadExecutor(); // 单个线程Executors.newFixedThreadPool(n); // n个线程Executors.newCachedThreadPool(); // 动态数量线程\n\n线程池的简单使用\nimport java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class Main &#123;    public static void main(String[] args) &#123;        ExecutorService threadPool = Executors.newSingleThreadExecutor();        //ExecutorService threadPool = Executors.newFixedThreadPool(5);        //ExecutorService threadPool = Executors.newCachedThreadPool();        try &#123;            for(int i = 1; i &lt;= 10; i++)&#123;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName());                &#125;);            &#125;        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;finally &#123;            threadPool.shutdown();        &#125;    &#125;&#125;/* 三个不同创建方式的输出结果分别为pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-1pool-1-thread-2pool-1-thread-3pool-1-thread-3pool-1-thread-3pool-1-thread-4pool-1-thread-1pool-1-thread-5pool-1-thread-2pool-1-thread-3pool-1-thread-6pool-1-thread-7pool-1-thread-4pool-1-thread-1pool-1-thread-8pool-1-thread-9pool-1-thread-2pool-1-thread-10pool-1-thread-5*/\n\n线程池本质：ThreadPoolExecutor\n//源码   public ThreadPoolExecutor(int corePoolSize,\t\t\t\t\t\t//核心线程大小                              int maximumPoolSize,\t\t\t\t\t//最大核心线程池大小                              long keepAliveTime,\t\t\t\t\t//超时了没人调用就会释放                              TimeUnit unit,\t\t\t\t\t\t//超时单位                              BlockingQueue&lt;Runnable&gt; workQueue,\t//阻塞队列                              ThreadFactory threadFactory,\t\t\t//创建线程的线程工厂                              RejectedExecutionHandler handler) &#123;\t//拒绝策略        if (corePoolSize &lt; 0 ||            maximumPoolSize &lt;= 0 ||            maximumPoolSize &lt; corePoolSize ||            keepAliveTime &lt; 0)            throw new IllegalArgumentException();        if (workQueue == null || threadFactory == null || handler == null)            throw new NullPointerException();        this.corePoolSize = corePoolSize;        this.maximumPoolSize = maximumPoolSize;        this.workQueue = workQueue;        this.keepAliveTime = unit.toNanos(keepAliveTime);        this.threadFactory = threadFactory;        this.handler = handler;        String name = Objects.toIdentityString(this);        this.container = SharedThreadContainer.create(name);    &#125;\n\n使用ThreadPoolExecutor创建自定义线程池\n创建线程数量不能大于最大核心线程数 + 阻塞队列大小\n当核心线程数与阻塞队列数都满时，开启最大核心线程\n四种拒绝策略：\n\nThreadPoolExecutor.AbortPolicy()：不处理多的线程，抛出异常\nThreadPoolExecutor.CallerRunsPolicy()：将线程丢回原本线程执行，可能是主线程，可能是其他线程\nThreadPoolExecutor.DiscardPolicy()：丢掉线程，不抛出异常\nThreadPoolExecutor.DiscardOldestPolicy()：尝试去和最早的线程竞争，不会抛出异常\n\nimport java.util.concurrent.*;public class Main &#123;    public static void main(String[] args) &#123;        ExecutorService threadPool = new ThreadPoolExecutor(                2, \t\t\t\t\t\t\t\t\t\t\t//核心线程数                5, \t\t\t\t\t\t\t\t\t\t\t//最大线程数                3, \t\t\t\t\t\t\t\t\t\t\t//超时时间                TimeUnit.SECONDS, \t\t\t\t\t\t\t//超时单位                new LinkedBlockingQueue&lt;Runnable&gt;(3), \t\t//阻塞队列                Executors.defaultThreadFactory(), \t\t\t// 默认线程工厂                new ThreadPoolExecutor.AbortPolicy() \t\t// 拒绝策略        );        try &#123;            for(int i = 1; i &lt;= 8; i++)&#123;                threadPool.execute(() -&gt; &#123;                    System.out.println(Thread.currentThread().getName());                &#125;);            &#125;        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;finally &#123;            threadPool.shutdown();        &#125;    &#125;&#125;/* 线程数等于最大核心线程数 + 阻塞队列大小时受理线程数为最大核心线程输出结果pool-1-thread-1pool-1-thread-3pool-1-thread-2pool-1-thread-1pool-1-thread-3pool-1-thread-4pool-1-thread-2pool-1-thread-5*/\n\nCPU密集型和IO密集型最大线程该如何定义？\nCPU密集型设置为CPU数+ 1，IO密集型设置为CPU数*2\n异步回调A是处理业务的一个步骤，A需要解决一个问题，这时候A可以问B，让B来告诉A答案，这期间，A可以继续做自己的事情，而不用因为B做的事而阻塞。\n// 无返回值的异步回调import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import java.util.concurrent.TimeUnit;public class Main &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; &#123;           try &#123;               TimeUnit.SECONDS.sleep(3);           &#125; catch (InterruptedException e) &#123;               throw new RuntimeException(e);           &#125;           System.out.println(Thread.currentThread().getName() + &quot;子线程执行完毕异步回调&quot;);        &#125;);        System.out.println(&quot;主线程执行&quot;);        completableFuture.get(); // 获取阻塞执行的结果    &#125;&#125;/*输出结果主线程执行ForkJoinPool.commonPool-worker-1子线程执行完毕异步回调*/\n\nimport java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;import java.util.concurrent.TimeUnit;public class Main &#123;    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;        CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;           try &#123;               TimeUnit.SECONDS.sleep(3);           &#125; catch (InterruptedException e) &#123;               throw new RuntimeException(e);           &#125;           System.out.println(Thread.currentThread().getName() + &quot;子线程执行完毕异步回调&quot;);           return &quot;Success&quot;;        &#125;);        System.out.println(&quot;主线程执行&quot;);        completableFuture.whenComplete((t, u) -&gt; &#123;            System.out.println(&quot;result &gt; &quot; + t); //结果            System.out.println(&quot;error  &gt; &quot; + u); //错误        &#125;).get();    &#125;&#125;/*输出结果主线程执行ForkJoinPool.commonPool-worker-1子线程执行完毕异步回调result &gt; Successerror  &gt; null*/\n\nJMMJMM是java的内存模型\n\n线程解锁前，必须把共享变量立刻刷回主存\n线程加锁前，必须读取主存中的最新值到工作内存中\n加锁和解锁是同一把锁\n\nJMM八种内存交互操作\n\nlock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。\nunlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。\nread（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用\nload（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。\nuse（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。\nassign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。\nstore（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。\nwrite（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。\n\n规则\n\n如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。\n不允许read和load、store和write操作之一单独出现\n不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。\n不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。\n一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。\n一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现\n如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值\n如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。\n对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。\n\nVolatileVolatile是java虚拟机提供的轻量级同步机制\n\n保证可见性\n不保证原子性\n禁止指令重排\n\n// 此时如果再main线程修改k的值，根据JMM模型，子线程无法检测到，因此会一直执行import java.util.concurrent.TimeUnit;public class Main &#123;    private static int k = 0;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(() -&gt; &#123;            while(k == 0)&#123;            &#125;        &#125;).start();        TimeUnit.SECONDS.sleep(3);        k = 1;        System.out.println(&quot;此时k的值为 -&gt; &quot; + k);    &#125;&#125;/*输出结果此时k的值为 -&gt; 1……………………………………无法停止*/\n\n// 添加volatile后，程序可正常退出，证明了volatile保证可见性import java.util.concurrent.TimeUnit;public class Main &#123;    private volatile static int k = 0;    public static void main(String[] args) throws InterruptedException &#123;        new Thread(() -&gt; &#123;            while(k == 0)&#123;            &#125;        &#125;).start();        TimeUnit.SECONDS.sleep(3);        k = 1;        System.out.println(&quot;此时k的值为 -&gt; &quot; + k);    &#125;&#125;/*输出结果此时k的值为 -&gt; 1Process finished with exit code 0*/\n\n原子性：不可分割，线程A在执行任务时，不能被打扰，也不能被分割，要么同时成功，要么同时失败\n// 验证volatile不保证原子性public class Main &#123;    private volatile static int k = 0;    private static void add()&#123;        k++;    &#125;    public static void main(String[] args) &#123;        // 定义20个线程，每个线程都给k加一，如果保证原子性的话，结果应该会是20000        for(int i = 0;  i &lt; 20; i++)&#123;            new Thread(() -&gt; &#123;                for(int j = 0; j &lt; 1000; j++)&#123;                    add();                &#125;            &#125;).start();        &#125;        while(Thread.activeCount() &gt; 2) &#123;            Thread.yield();        &#125;        System.out.println(Thread.currentThread().getName() + &quot; &gt; &quot; +k);    &#125;&#125;//输出：main &gt; 19986\n\n单例模式\n饿汉式单例\n\npublic class Hungry &#123;    private Hungry()&#123;    &#125;    private final static Hungry HUNGRY = new Hungry();    public static Hungry getInstance()&#123;        return HUNGRY;    &#125;&#125;\n\n\n懒汉式模式\n\npublic class LazyMan &#123;    private LazyMan()&#123;        System.out.println(Thread.currentThread().getName() + &quot;ok&quot;);    &#125;        private volatile static LazyMan lazyMan;        // 双重检测锁模式，DCL懒汉式    public static LazyMan getInstance()&#123;        if(lazyMan == null)&#123;            synchronized (lazyMan.Class)&#123;                if (lazyMan == null)&#123;                    lazyMan = new LazyMan();                &#125;            &#125;        &#125;        return lazyMan;    &#125;&#125;\n\n\n静态内部类\n\npublic class Holder &#123;    private Holder()&#123;            &#125;    public static Holder getInstance()&#123;        return InnerClass.HOLDER;    &#125;        public static class InnerClass &#123;        private static final Holder HOLDER = new Holder();    &#125;    &#125;\n\n\n枚举模式\n\npublic enum Holder &#123;    INSTANCE;    public Holder getInstance()&#123;        return INSTANCE;    &#125;&#125;\n\n各种锁\n可重入锁\n\n拿到外面的锁后，就可以自动拿到里面的锁\n\n自旋锁\n\nimport java.util.concurrent.atomic.AtomicReference;public class SpinLockDemo &#123;    AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;&gt;();    public void getLock() &#123;        Thread thread = Thread.currentThread();        System.out.println(Thread.currentThread().getName() + &quot;加锁&quot;);        while (!atomicReference.compareAndSet(null, thread)) &#123;        &#125;    &#125;        public void unLock()&#123;        Thread thread = Thread.currentThread();        System.out.println(Thread.currentThread().getName() + &quot;解锁&quot;);        atomicReference.compareAndSet(thread, null);    &#125;&#125;\n\n","categories":["java"],"tags":["java多线程"]},{"title":"MySQL基础","url":"/2023/02/25/MySQL%E5%9F%BA%E7%A1%80/","content":"使用DISTINCT关键字，指示MySQL 列中只返回不同的值\n\n\nselect DISTINCT vend_id from products\n\n使用LIMIT限制返回结果\n-- 限制输出结果只有五行select prod_name from products LIMIT 5-- 返回从行5开始的5行select prod_name from products LIMIT 5,5\n\nIS NULL空值过滤\nselect prod_name from products where prod_price IS NULL\n\nLIKE通配符\n-- 筛选以jet开头的数据select prod_id, prod_name from products where prod_name LIKE &#x27;jet%&#x27;-- 筛选所有包含jet的数据select prod_id, prod_name from products where prod_name LIKE &#x27;%jet%&#x27;-- 筛选以s开头，e结尾的数据select prod_id, prod_name from products where prod_name LIKE &#x27;s%e&#x27;\n\n下划线_通配符\n-- 下划线通配符只匹配单个字符select prod_id, prod_name from products where prod_name LIKE &#x27;_tom anvi1&#x27;\n\n正则表达式搜索-- 匹配1000， 2000 ……select prod_id, prod_name from products where prod_name REGEXP &#x27;.000&#x27;select prod_id, prod_name from products where prod_name REGEXP &#x27;1000|2000&#x27;-- 匹配1 ton， 2ton， 3tonselect prod_id, prod_name from products where prod_name REGEXP &#x27;[1-3] ton&#x27;-- 匹配特殊字符. - 等select prod_id, prod_name from products where prod_name REGEXP &#x27;\\\\.&#x27;-- 匹配连在一起的4个数字select prod_id, prod_name from products where prod_name REGEXP [[:digit:]]&#123;4&#125;\n\n拼接字段\n-- 输出 杨子涵（男）select concat(name, &#x27;(&#x27;, sex, &#x27;)&#x27;) from infos\n\n去除空格\nselect RTrim(name) from infos\n\n使用别名AS\nselect concat(name, &#x27;(&#x27;, sex, &#x27;)&#x27;) as basic_info from infos\n\n分组-- 统计每个id有多少个select id, count(*) from products group by id-- 要列出至少有两个订单的所有顾客，由于where指定的是行，而having指定的是分组，因此要使用havingselect cust_id, count(*) as numorder from orders group by cust_id having count(*) &gt;= 2-- 列出具有2个（含）以上、价格为10（含）以上的产品的供应商select vend_id, count(*) as num_prodsfrom productswhere prod_price &gt;= 10group by vent_idhaving count(*) &gt;= 2\n\n子查询-- 列出订购物品TNT2的所有客户-- 不使用子查询-- 1)select order_num from orderitems where prod_id = &#x27;TNT2&#x27;-- 2)select cust_id from orders where order_num in(20005, 20007)-- 使用子查询select cust_id from orders where order_num in(select order_num from orderitems where prod_id = &#x27;TNT2&#x27;)\n\n连结表-- 内联结select vend_name, prod_name, prod_pricefrom vendors inner join productson vendors.vend_id = products.vend_id-- 自联结-- 使用AS在SQL中多次使用相同表select p1.prod_id, p1.prod_namefrom products as p1, products as p2where p1.vend_id = p2.vend_id-- 外联结-- right表示选择右边表的所有行select vend_name, prod_name, prod_pricefrom vendors right outer join productson vendors.vend_id = products.vend_id\n\n组合查询\n-- 使用UNION组合多个查询select vend_id, prod_id, prod_pricefrom productswhere prod_price &lt;= 5-- union会自动删除重复的行，如果取消，使用union allunion (union all)select vend_id, prod_id, prod_pricefrom productswhere vend_id in (1001, 1002)-- 最后使用排序，会对整个结果都排序order by vend_id, prod_price\n\n全文搜索创建表时，启用全文搜索\ncreate table productnotes(\tnote_id\t\tint\t\t\tnot null auto_increment,    prod_id \tchar(10)\tnot null,    note_date \tdatetime\tnot null,    note_text\ttext\t\tnull,    primary key(note_id),    fulltext(note_text))engine=myisam-- 检索出包含rabbit的记录select note_textfrom productnoteswhere match(note_text) against(&#x27;rabbit&#x27;)-- 布尔文本搜索-- 不包含rabbit的记录select note_textfrom productnoteswhere match(note_text) against(&#x27;rabbit&#x27;, IN BOOLEAN MODE)-- 包含rabbit。但不包含haven的记录select note_textfrom productnoteswhere match(note_text) against(&#x27;rabbit -rope*&#x27;, IN BOOLEAN MODE)\n\n插入检索出的数据insert into customers(\tid,    phone,    email)selectid,phone,emailfrom infos\n\n更新表alter table vendors add vend_phone char(20)alter table vendors drop column vend_phonealter table orders add constraint products_vendors foreign key (vend_id) references vendors (vend_id)\n\n存储过程-- 创建存储过程create procedure productpricing()begin\tselect avg(prod_price) as priceaverge\tfrom products;end;-- 调用存储过程call productpricing()-- 删除存储过程drop procedure productpricing if exists;-- 传递变量-- MySQL支持IN（传递给存储过程）、OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。create procedure productpricing(\tout p1 decimal(8, 2)    out ph decimal(8, 2)    out pa decimal(8, 2))begin\tselect min(prod_price)\tinto p1\tfrom products;\tselect max(prod_price)\tinto ph\tfrom products;\tselect avg(prod_price)\tinto pa\tfrom products;end;call productpricing(\t@pricelow    @pricehigh    @priceaverage)select @pricelow, @pricehigh, @priceaverage;-- 使用传入示例create procedure productpricing(\tin onumber int,    out ototal decimal(8, 2))begin\tselect sum(item_price * quantity)\tfrom orderitems\twhere order_num = onumber\tinto totalend call productpricing(\t200005,    @total)select @total\n\n完成存储过程示例\ncreate procedure ordertotal(\tin onumber int,    in taxable boolen,    out ototal decimal(8, 2))comment &#x27;obtain order total, optionally adding tax&#x27;begin\tdeclare total decimal(8, 2);\tdeclare tax int default 6;\t\tselect sum(item_price * quantity)\tfrom orderitems\twhere order_num = onumber\tinto total;\t\tif taxable then\t\tselect total + (total / 100 * taxrate) into total;\tend if;\t\tselect total into ototalend;call ordertotal(20005, 0, @total);select @total;-- 检查存储过程show create procedure ordertotal;\n\n游标MySQL检索操作返回一组称为结果集的行。这组返 回的行都是与SQL语句相匹配的行（零行或多行）。使用简单的SELECT语 句，例如，没有办法得到第一行、下一行或前10行，也不存在每次一行 地处理所有行的简单方法（相对于成批地处理它们）。 有时，需要在检索出来的行中前进或后退一行或多行。这就是使用 游标的原因。游标（cursor）是一个存储在MySQL服务器上的数据库查询， 它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游 标之后，应用程序可以根据需要滚动或浏览其中的数据。\n-- 此时ordernumbers存游标存储了select的结果集，可根据需要打开游标逐行滑动数据create procedure processorders()begin\tdeclare o int; \tdeclare ordernumbers cursor\tfor\tselect order_num from orders;\t-- 游标执行完之后将done设置为1\tdeclare continue handler for not found set done = 1;\topen ordernumbers;\trepeat\t\tfetch ordernumbers into o;\tuntil done end repeat;\tclose ordernumbers;end;\n\n\n\ncreate procedure processorders()begin\tdeclare done boolean default 0;\tdeclare o int;\tdeclare t decimal(8, 2);\t\tdeclare ordernumbers cursor;\tdeclare continue handler for not found set done = 1;\t\tcreate table if not exists ordertotals(    \torder_num int,        total decimal(8, 2)    )    open ordernumbers;        repeat    \tfetch ordernumbers into o;    \tcall ordertotal(0, 1, t);    \tinsert into ordertotals(order_num, total) values(0, t);    until done end repeat;        close ordernumbers;    end;\t\n\n触发器想要某些语句在事件发生时自动执行，使用触发器\n每个表的每个事件每次只允许一个触发器\n-- 在进行每一行插入时执行create trigger newproduct after insert on productsfor each row select &#x27;product added&#x27;;-- 删除触发器drop trigger newproduct;-- 在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；-- 在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；-- 在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；-- 返回插入新值的order_numcreate trigger newproduct after insert on productsfor each row select new.order_num-- 使用OLD保存将要被删除的行到一个存档表中create trigger deleteorder before delete on ordersfor each rowbegin\tinsert into archive_orders(order_num, order_date, cust_id)\tvalues(old.order_num, old.order_date, old.cust_id);end;-- 下面的例子保证州名缩写总是大写create trigger deleteorder before update on vendorsfor each row set new.vend_state = upper(new.vend_state);\n\n事务处理为了防止执行一段sql操作时，某一个sql语句出现错误，所以要使用事务来防止出错\n-- 1-回退select * from ordertotals;-- 开启一个事务start transaction;-- 删除ordertotals中的所有内容delete from ordertotals;-- 此时ordertotals表为空select * from ordertotals;-- 回退start transaction之后的所有操作rollback;-- 此时ordertotals表不为空select * from ordertotals;-- 2-提交start transaction;delete from ordertotals where order_num = 20010;delete from orders where order_num = 20010;-- 提交，此时如果上面的某条delete语句出错，则两条delete语句都不会执行commit;-- 3-保留点，在某个步骤出错时，不用全部回退，只回退到出错点start transaction;savepoint delete1;delete from ordertotals where order_num = 20010;savepoint delete2;delete from orders where order_num = 20010;rollback delete1;commit;","categories":["MySQL"],"tags":["MySQL基础"]},{"title":"Shell","url":"/2023/02/25/Shell/","content":"循环， 函数， 文件重定向\n\n\n循环\nfor var in val1 val2 val3do\t#语句一\t#语句二done#例子for file in `ls`do\techo $filedone#会输出所有文件的名称\n\nfor((i=1; i&lt;=10; i++))do\techo $idone\n\nwhile read filedo\techo $namedone\n\nuntil conditiondo\t#语句一\t#语句二done\n\n#输出1 - 10内的所有奇数for((i=1; i&lt;=10;i++))do\tif [`expr $i % 2` -eq 0]\tthen\t\tcontinue\tfi\techo $idone\n\n\n\n函数\nfunc()&#123;\tname=yzh\techo $name\t\treturn 123&#125;output=$(func)ret=$?#传递参数时，$0代表文件名，$1代表第一个参数，以此类推func()&#123;\tnum1=$1\tnum2=$2\techo $num1\techo $num2&#125;func 1 2\n\n\n\n文件重定向\ncommand &gt; file #将stdout重定向到file中command &lt; file #将stdin重定向到file中command &gt;&gt; file #将stdout以追加的方式重定向到file中command n &gt; file #将文件描述符n重定向到file中command n &gt;&gt; file #将文件描述符n以追加方式重定向到file中\n\necho -e &quot;Hello&quot; &gt; output.txtecho &quot;World&quot; &gt;&gt; output.txtread str &lt; output.txt\n\n\n\n","categories":["Linux"],"tags":["Linux"]},{"title":"Spring基础-AOP","url":"/2023/03/11/Spring%E5%9F%BA%E7%A1%80-AOP/","content":"Spring第三集 -&gt; AOP\n\nAOP-动态代理说明\n动态代理分为JDK动态代理和cglib动态代理\n当目标类有接口的情况使用JDK动态代理和cglib动态代理，没有接口时只能使用cglib动态代理\nJDK动态代理动态生成的代理类会在com.sun.proxy包下，类名为$proxy1，和目标类实现相同的接口\ncglib动态代理动态生成的代理类会和目标在在相同的包下，会继承目标类\n动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。\ncglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口。\nAspectJ：是AOP思想的一种实现。本质上是静态代理，将代理逻辑“织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。public class ProxyFactory &#123;    private Object target;    public ProxyFactory(Object target) &#123;        this.target = target;    &#125;    public Object getProxy()&#123;        /**         * newProxyInstance()：创建一个代理实例         * 其中有三个参数：         * 1、classLoader：加载动态生成的代理类的类加载器         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法         */        ClassLoader classLoader = target.getClass().getClassLoader();        Class[]&lt;?&gt; interfaces = target.getClass().getInterfaces();        InvocationHandler invocationHandler = new InvocationHandler() &#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                /**                 * proxy：代理对象                 * method：代理对象需要实现的方法，即其中需要重写的方法                 * args：method所对应方法的参数                 */                Object result = null;                try &#123;                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，参数：&quot;+ Arrays.toString(args));                    result = method.invoke(target, args);                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，结果：&quot;+ result);                &#125; catch (Exception e) &#123;                    e.printStackTrace();                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，异常：&quot;+e.getMessage());                &#125; finally &#123;                    System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，方法执行完毕&quot;);                &#125;                return result;            &#125;        &#125;;        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);    &#125;&#125;\n\n测试\n@Testpublic void testDynamicProxy()&#123;    ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl());    Calculator proxy = (Calculator) factory.getProxy();    proxy.div(1,0);&#125;\n\nAOP相关概念横切关注点分散在每个各个模块中解决同一样的问题，如用户验证、日志管理、事务处理、数据缓存都属于横切关注点。\n从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。\n这个概念不是语法层面的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。\n通知（增强）增强，通俗说，就是你想要增强的功能，比如 安全，事务，日志等。\n每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。\n\n前置通知：在被代理的目标方法前执行\n返回通知：在被代理的目标方法成功结束后执行\n异常通知：在被代理的目标方法异常结束后执行\n后置通知：在被代理的目标方法最终结束后执行\n环绕通知：使用try...catch...finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置\n\n切面封装通知方法的类。\n目标被代理的目标对象。\n代理向目标对象应用通知之后创建的代理对象。\n连接点这也是一个纯逻辑概念，不是语法定义的。\n把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。通俗说，就是spring允许你使用通知的地方\n切入点定位连接点的方式。\n每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。\n如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。\nSpring 的 AOP 技术可以通过切入点定位到特定的连接点。通俗说，要实际去增强的方法\n切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。\n作用\n简化代码：把方法中固定位置的重复的代码抽取出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。\n\n代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被套用了切面逻辑的方法就被切面给增强了。\n\n\nAOP实例创建切面类并配置\n// @Aspect表示这个类是一个切面类@Aspect// @Component注解保证这个切面类能够放入IOC容器@Componentpublic class LogAspect &#123;        @Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)    public void beforeMethod(JoinPoint joinPoint)&#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);    &#125;    @After(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)    public void afterMethod(JoinPoint joinPoint)&#123;        String methodName = joinPoint.getSignature().getName();        System.out.println(&quot;Logger--&gt;后置通知，方法名：&quot;+methodName);    &#125;    // returning获取返回值    @AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)    public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123;        String methodName = joinPoint.getSignature().getName();        System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result);    &#125;    // throwable获取异常    @AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)    public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123;        String methodName = joinPoint.getSignature().getName();        System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex);    &#125;        @Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)    public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123;        String methodName = joinPoint.getSignature().getName();        String args = Arrays.toString(joinPoint.getArgs());        Object result = null;        try &#123;            System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;);            //目标对象（连接点）方法的执行            result = joinPoint.proceed();            System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;);        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();            System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;);        &#125; finally &#123;            System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;);        &#125;        return result;    &#125;    &#125;\n\n在Spring的配置文件中配置：\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--        基于注解的AOP的实现：        1、将目标对象和切面交给IOC容器管理（注解+扫描）        2、开启AspectJ的自动代理，为目标对象自动生成代理        3、将切面类通过注解@Aspect标识    --&gt;    &lt;context:component-scan base-package=&quot;com.tzuhan.aop.annotation&quot;&gt;&lt;/context:component-scan&gt;    &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt;\n\nexecution语法细节\n\n用*号代替“权限修饰符”和“返回值”部分表示“权限修饰符”和“返回值”不限\n\n在包名的部分，一个“*”号只能代表包的层次结构中的一层，表示这一层是任意的。\n\n例如：*.Hello匹配com.Hello，不匹配com.atguigu.Hello\n\n\n在包名的部分，使用“*..”表示包名任意、包的层次深度任意\n\n在类名的部分，类名部分整体用*号代替，表示类名任意\n\n在类名的部分，可以使用*号代替类名的一部分\n\n例如：*Service匹配所有名称以Service结尾的类或接口\n\n\n在方法名部分，可以使用*号表示方法名任意\n\n在方法名部分，可以使用*号代替方法名的一部分\n\n例如：*Operation匹配所有方法名以Operation结尾的方法\n\n\n在方法参数列表部分，使用(..)表示参数列表任意\n\n在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头\n\n在方法参数列表部分，基本数据类型和对应的包装类型是不一样的\n\n切入点表达式中使用 int 和实际方法中 Integer 是不匹配的\n\n\n在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符\n\n例如：execution(public int ..Service.(.., int))\t正确例如：execution( int *..Service.(.., int))\t错误\n\n\n\n重用切入点表达式声明\n@Pointcut(&quot;execution(* com.tzuhan.aop.annotation.*.*(..))&quot;)public void pointCut()&#123;&#125;\n\n在同一个切面中使用\n@Before(&quot;pointCut()&quot;)public void beforeMethod(JoinPoint joinPoint)&#123;    String methodName = joinPoint.getSignature().getName();    String args = Arrays.toString(joinPoint.getArgs());    System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125;\n\n在不同切面中使用\n@Before(&quot;com.tzuhan.aop.CommonPointCut.pointCut()&quot;)public void beforeMethod(JoinPoint joinPoint)&#123;    String methodName = joinPoint.getSignature().getName();    String args = Arrays.toString(joinPoint.getArgs());    System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125;\n\n基于XML的AOP实现\n&lt;context:component-scan base-package=&quot;com.tzuhan.aop.xml&quot;&gt;&lt;/context:component-scan&gt;&lt;aop:config&gt;    &lt;!--配置切面类--&gt;    &lt;aop:aspect ref=&quot;loggerAspect&quot;&gt;        &lt;aop:pointcut id=&quot;pointCut&quot;                    expression=&quot;execution(* com.tzuhan.aop.xml.CalculatorImpl.*(..))&quot;/&gt;        &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:before&gt;        &lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after&gt;        &lt;aop:after-returning method=&quot;afterReturningMethod&quot; returning=&quot;result&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after-returning&gt;        &lt;aop:after-throwing method=&quot;afterThrowingMethod&quot; throwing=&quot;ex&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:after-throwing&gt;        &lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointCut&quot;&gt;&lt;/aop:around&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;\n\n","categories":["java"],"tags":["Spring"]},{"title":"Spring基础-XML实现IoC","url":"/2023/03/08/Spring%E5%9F%BA%E7%A1%80-XML%E5%AE%9E%E7%8E%B0/","content":"Spring第一集 -&gt; XML实现IoC\n\n获取Bean根据id获取由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。上个实验中我们使用的就是这种方式。\n根据类型获取@Testpublic void testHelloWorld1()&#123;\tApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    HelloWorld bean = ac.getBean(HelloWorld.class);    bean.sayHello();&#125;\n\n根据id和类型@Testpublic void testHelloWorld2()&#123;\tApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);    HelloWorld bean = ac.getBean(&quot;helloworld&quot;, HelloWorld.class);    bean.sayHello();&#125;\n\n注意当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个\n当IOC容器中一共配置了两个：\n&lt;bean id=&quot;helloworldOne&quot; class=&quot;com.tzuhan.HelloWorld&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;helloworldTwo&quot; class=&quot;com.tzuhan.HelloWorld&quot;&gt;&lt;/bean&gt;\n\n根据类型获取时会抛出异常：\n\norg.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type ‘com.atguigu.spring6.bean.HelloWorld’ available: expected single matching bean but found 2: helloworldOne,helloworldTwo\n\n扩展如果组件类实现了接口，根据接口类型可以获取 bean 吗？\n\n可以，前提是bean唯一\n\n如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取 bean 吗？\n\n不行，因为bean不唯一\n\n结论\n根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。\njava中，instanceof运算符用于判断前面的对象是否是后面的类，或其子类、实现类的实例。如果是返回true，否则返回false。也就是说：用instanceof关键字做判断时， instanceof 操作符的左右操作必须有继承或实现关系\nBean—XMLSetter依赖注入声明类，并写好getter和setter\npackage com.atguigu.spring6.bean;public class Student &#123;    private Integer id;    private String name;    private Integer age;    private String sex;    public Student() &#123;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;    @Override    public String toString() &#123;        return &quot;Student&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n配置bean时为属性赋值\n&lt;bean id=&quot;studentOne&quot; class=&quot;com.tzuhan.Student&quot;&gt;    &lt;!-- property标签：通过组件类的setXxx()方法给组件对象设置属性 --&gt;    &lt;!-- name属性：指定属性名（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关） --&gt;    &lt;!-- value属性：指定属性值 --&gt;    &lt;property name=&quot;id&quot; value=&quot;202016060211&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;name&quot; value=&quot;zihan&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;sex&quot; value=&quot;man&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n\n构造器依赖注入写好构造函数\npublic Student(Integer id, String name, Integer age, String sex) &#123;    this.id = id;    this.name = name;    this.age = age;    this.sex = sex;&#125;\n\n配置xml\n&lt;bean id=&quot;studentTwo&quot; class=&quot;com.tzuhan.Student&quot;&gt;    &lt;constructor-arg value=&quot;202016060211&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg value=&quot;zihan&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg value=&quot;20&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg value=&quot;man&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;\n\n\n注意：\nconstructor-arg标签还有两个属性可以进一步描述构造器参数：\n\nindex属性：指定参数所在位置的索引（从0开始）\nname属性：指定参数名\n\n\n特殊值处理null值\n&lt;property name=&quot;name&quot;&gt;    &lt;null /&gt;&lt;/property&gt;\n\n\n注意：\n&lt;property name=&quot;name&quot; value=&quot;null&quot;&gt;&lt;/property&gt;\n\n以上写法，为name所赋的值是字符串null\n\n对象类型属性注入package com.tzuhan.iocxml;public class User &#123;    private Person person;    public Person getPerson() &#123;        return person;    &#125;    public void setPerson(Person person) &#123;        this.person = person;    &#125;&#125;class Person &#123;    private String name;    private String age;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getAge() &#123;        return age;    &#125;    public void setAge(String age) &#123;        this.age = age;    &#125;&#125;\n\n引用外部Bean\n   &lt;bean id=&quot;person&quot; class=&quot;com.tzuhan.iocxml.Person&quot;&gt;       &lt;property name=&quot;name&quot; value=&quot;zihan&quot;&gt;&lt;/property&gt;       &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;&lt;!--用ref--&gt;   &lt;bean id=&quot;user&quot; class=&quot;com.tzuhan.iocxml.User&quot;&gt;       &lt;property name=&quot;person&quot; ref=&quot;person&quot;&gt;&lt;/property&gt;   &lt;/bean&gt;\n\n内部Bean\n&lt;bean id=&quot;user&quot; class=&quot;com.tzuhan.iocxml.User&quot;&gt;    &lt;property name=&quot;person&quot;&gt;        &lt;bean id=&quot;person&quot; class=&quot;com.tzuhan.iocxml.Person&quot;&gt;            &lt;property name=&quot;name&quot; value=&quot;zihan&quot;&gt;&lt;/property&gt;            &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;    &lt;/property&gt;&lt;/bean&gt;\n\n级联属性赋值\n&lt;bean id=&quot;person&quot; class=&quot;com.tzuhan.iocxml.Person&quot;&gt;&lt;/bean&gt;&lt;!--用ref--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.tzuhan.iocxml.User&quot;&gt;    &lt;property name=&quot;person&quot; ref=&quot;person&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;user&quot; class=&quot;com.tzuhan.iocxml.User&quot;&gt;    &lt;property name=&quot;person&quot; ref=&quot;person&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;person.name&quot; value=&quot;zihan&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;person.age&quot; value=&quot;20&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n\n集合类型属性赋值以Map、LIst、Array为例\npublic class User &#123;    private String name;    private Map&lt;Integer, String&gt; map;    private List&lt;Integer&gt; list;    private int[] grade;    public List&lt;Integer&gt; getList() &#123;        return list;    &#125;    public Map&lt;Integer, String&gt; getMap() &#123;        return map;    &#125;    public void setList(List&lt;Integer&gt; list) &#123;        this.list = list;    &#125;    public void setMap(Map&lt;Integer, String&gt; map) &#123;        this.map = map;    &#125;    public int[] getGrade() &#123;        return grade;    &#125;    public void setGrade(int[] grade) &#123;        this.grade = grade;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--User对象创建--&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.tzuhan.iocxml.User&quot;&gt;        &lt;property name=&quot;list&quot;&gt;            &lt;list&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;property name=&quot;map&quot;&gt;            &lt;map&gt;                &lt;entry key=&quot;1&quot; value=&quot;test1&quot;&gt;&lt;/entry&gt;                &lt;entry key=&quot;2&quot; value=&quot;test2&quot;&gt;&lt;/entry&gt;            &lt;/map&gt;        &lt;/property&gt;        &lt;property name=&quot;grade&quot;&gt;            &lt;array&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;        &lt;property name=&quot;name&quot; value=&quot;zihan&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n集合类型bean与p命名空间\npackage com.tzuhan.iocxml;import java.util.Map;public class User &#123;    private Map&lt;Integer, Person&gt; map;    public Map&lt;Integer, Person&gt; getMap() &#123;        return map;    &#125;    public void setMap(Map&lt;Integer, Person&gt; map) &#123;        this.map = map;    &#125;&#125;class Person &#123;    private int level;    private String username;    public int getLevel() &#123;        return level;    &#125;    public void setLevel(int level) &#123;        this.level = level;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;&#125;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;util:map id=&quot;personMap&quot;&gt;        &lt;entry key=&quot;1&quot; value-ref=&quot;person1&quot;&gt;&lt;/entry&gt;        &lt;entry key=&quot;2&quot; value-ref=&quot;person2&quot;&gt;&lt;/entry&gt;    &lt;/util:map&gt;        &lt;bean id=&quot;user&quot; class=&quot;com.tzuhan.iocxml.User&quot;          p:map-ref=&quot;personMap&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;person1&quot; class=&quot;com.tzuhan.iocxml.Person&quot;          p:level=&quot;1&quot; p:username=&quot;zihan&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;person2&quot; class=&quot;com.tzuhan.iocxml.Person&quot;          p:level=&quot;2&quot; p:username=&quot;lulu&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n\nBean作用域\n\n\n取值\n含义\n创建对象的时机\n\n\n\nsingleton（默认）\n在IOC容器中，这个bean的对象始终为单实例\nIOC容器初始化时\n\n\nprototype\n这个bean在IOC容器中有多个实例\n获取bean时\n\n\n\n\n\n取值\n含义\n\n\n\nrequest\n在一个请求范围内有效\n\n\nsession\n在一个会话范围内有效\n\n\n&lt;bean class=&quot;com.tzuhan.User&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;\n\n@Testpublic void testBeanScope()&#123;    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-scope.xml&quot;);    User user1 = ac.getBean(User.class);    User user2 = ac.getBean(User.class);    System.out.println(user1==user2);  // false&#125;\n\nBean生命周期生命周期过程\n\nbean对象创建（调用无参构造器）\n\n给bean对象设置属性\n\nbean的后置处理器（初始化之前）\n\nbean对象初始化（需在配置bean时指定初始化方法）\n\nbean的后置处理器（初始化之后）\n\nbean对象就绪可以使用\n\nbean对象销毁（需在配置bean时指定销毁方法）\n\nIOC容器关闭\n\n\npublic class User &#123;    private Integer id;    private String username;    private String password;    private Integer age;    public User() &#123;        System.out.println(&quot;生命周期：1、创建对象，调用无参构造&quot;);    &#125;    public User(Integer id, String username, String password, Integer age) &#123;        this.id = id;        this.username = username;        this.password = password;        this.age = age;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        System.out.println(&quot;生命周期：2、依赖注入，设置属性值&quot;);        this.id = id;    &#125;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;    public void initMethod()&#123;        System.out.println(&quot;生命周期：4、bean对象初始化&quot;);    &#125;    public void destroyMethod()&#123;        System.out.println(&quot;生命周期：7、bean对象销毁&quot;);    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;id=&quot; + id +                &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; +                &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n&lt;!-- 使用init-method属性指定初始化方法 --&gt;&lt;!-- 使用destroy-method属性指定销毁方法 --&gt;&lt;bean class=&quot;com.tzuhan.User&quot; scope=&quot;prototype&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt;    &lt;property name=&quot;id&quot; value=&quot;202016060211&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;username&quot; value=&quot;admin&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/property&gt;&lt;/bean&gt;\n\n测试\n@Testpublic void testLife()&#123;    ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-lifecycle.xml&quot;);    User bean = ac.getBean(User.class);    System.out.println(&quot;生命周期：6、通过IOC容器获取bean并使用&quot;);    ac.close();&#125;\n\n后置处理器\nbean的后置处理器会在生命周期的初始化前后添加额外的操作，需要实现BeanPostProcessor接口，且配置到IOC容器中，需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行\n创建bean的后置处理器：\nimport org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class MyBeanProcessor implements BeanPostProcessor &#123;        @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;生命周期：3&quot; +&quot;Bean后置处理器，初始化前执行&quot; beanName + &quot; = &quot; + bean);        return bean;    &#125;        @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;生命周期：5&quot; +&quot;Bean后置处理器，初始化后执行&quot; beanName + &quot; = &quot; + bean);        return bean;    &#125;&#125;\n\n&lt;!-- bean的后置处理器要放入IOC容器才能生效 --&gt;&lt;bean id=&quot;myBeanProcessor&quot; class=&quot;com.tzuhan.process.MyBeanProcessor&quot;/&gt;\n\n基于xml自动装配\n自动装配：\n根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值\n\n创建类UserController\npackage com.atguigu.spring6.autowire.controllerpublic class UserController &#123;    private UserService userService;    public void setUserService(UserService userService) &#123;        this.userService = userService;    &#125;    public void saveUser()&#123;        userService.saveUser();    &#125;&#125;\n\n创建接口UserService\npackage com.atguigu.spring6.autowire.servicepublic interface UserService &#123;    void saveUser();&#125;\n\n创建类UserServiceImpl实现接口UserService\npackage com.atguigu.spring6.autowire.service.implpublic class UserServiceImpl implements UserService &#123;    private UserDao userDao;    public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;    &#125;    @Override    public void saveUser() &#123;        userDao.saveUser();    &#125;&#125;\n\n创建接口UserDao\npackage com.atguigu.spring6.autowire.daopublic interface UserDao &#123;    void saveUser();&#125;\n\n创建类UserDaoImpl实现接口UserDao\npackage com.atguigu.spring6.autowire.dao.implpublic class UserDaoImpl implements UserDao &#123;    @Override    public void saveUser() &#123;        System.out.println(&quot;保存成功&quot;);    &#125;&#125;\n\n②配置bean\n\n使用bean标签的autowire属性设置自动装配效果\n自动装配方式：byType\nbyType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值\n若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null\n若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常NoUniqueBeanDefinitionException\n\n&lt;bean id=&quot;userController&quot; class=&quot;com.tzuhan.controller.UserController&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.tzuhan.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.tzuhan.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;\n\n\n自动装配方式：byName\nbyName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值\n\n&lt;bean id=&quot;userController&quot; class=&quot;com.tzuhan.controller.UserController&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.tzuhan.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.tzuhan.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.tzuhan.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.tzuhan.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;\n\n测试\n@Testpublic void testAutoWireByXML()&#123;    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);    UserController userController = ac.getBean(UserController.class);    userController.saveUser();&#125;\n\n","categories":["java"],"tags":["Spring"]},{"title":"Spring基础-注解实现IoC","url":"/2023/03/10/Spring%E5%9F%BA%E7%A1%80-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E7%AE%A1%E7%90%86Bean/","content":"Spring第二集 -&gt; 注解实现IoC\n\n注解方式实现IOC配置文件&lt;!--引入context--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt;&lt;!--基本写法--&gt;\t&lt;context:component-scan base-package=&quot;com.tzuhan.ioc&quot;&gt;&lt;/context:component-scan&gt;\n\n只扫描指定组件&lt;!--只扫描指定组件--&gt;&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt;    &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt;    &lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt;    &lt;!-- 此时必须设置use-default-filters=&quot;false&quot;，因为默认规则即扫描指定包下所有类 --&gt;    &lt;!--  \t\ttype：设置排除或包含的依据\t\ttype=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名\t\ttype=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名\t--&gt;    &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;\t&lt;!--&lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;&lt;/context:component-scan&gt;\n\n指定要排除的组件&lt;!--指定要排除的组件--&gt;&lt;context:component-scan base-package=&quot;com.tzuhan.ioc&quot;&gt;    &lt;!-- context:exclude-filter标签：指定排除规则 --&gt;    &lt;!--         type：设置排除或包含的依据        type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名        type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名    --&gt;    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;    &lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;&lt;/context:component-scan&gt;\n\n\n\n使用注解定义Bean\n\n\n注解\n说明\n\n\n\n@Component\n该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。  使用时只需将该注解标注在相应类上即可。\n\n\n@Repository\n该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。\n\n\n@Service\n该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。\n\n\n@Controller\n该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。\n\n\n注入@Autowired注入单独使用@Autowired注解，默认根据类型装配。【默认是byType】\n有两处需要注意：\n第一：该注解可以标注在哪里？\n\n构造方法上\n方法上\n形参上\n属性上\n注解上\n\n第二：该注解有一个required属性，默认值是true，表示在注入的时候要求被注入的Bean必须是存在的，如果不存在则报错。如果required属性设置为false，表示注入的Bean存在或者不存在都没关系，存在的话就注入，不存在的话，也不报错。\n属性注入@Servicepublic class UserServiceImpl implements UserService &#123;    @Autowired    private UserDao userDao;    @Override    public void out() &#123;        userDao.print();        System.out.println(&quot;Service层执行结束&quot;);    &#125;&#125;\n\nset方法注入public class UserServiceImpl implements UserService &#123;    private UserDao userDao;    @Autowired    public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;    &#125;    @Override    public void out() &#123;        userDao.print();        System.out.println(&quot;Service层执行结束&quot;);    &#125;&#125;\n\n构造方法注入public class UserServiceImpl implements UserService &#123;    private UserDao userDao;    @Autowired    public UserServiceImpl(UserDao userDao) &#123;        this.userDao = userDao;    &#125;    @Override    public void out() &#123;        userDao.print();        System.out.println(&quot;Service层执行结束&quot;);    &#125;&#125;\n\n形参上注入@Servicepublic class UserServiceImpl implements UserService &#123;    private UserDao userDao;    public UserServiceImpl(@Autowired UserDao userDao) &#123;        this.userDao = userDao;    &#125;    @Override    public void out() &#123;        userDao.print();        System.out.println(&quot;Service层执行结束&quot;);    &#125;&#125;\n\n当有参数的构造方法只有一个时，@Autowired注解可以省略。\n@Autowired注解和@Qualifier注解联合实现按名称注入\n@Servicepublic class UserServiceImpl implements UserService &#123;    @Autowired    @Qualifier(&quot;userDaoImpl&quot;) // 指定bean的名字    private UserDao userDao;    @Override    public void out() &#123;        userDao.print();        System.out.println(&quot;Service层执行结束&quot;);    &#125;&#125;\n\n@Resource注入和@Autowired的区别\n\n@Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。\n@Autowired注解是Spring框架自己的。\n@Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。\n@Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。\n@Resource注解用在属性上、setter方法上。\n@Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。\n\n 使用时需要引入依赖\n&lt;dependency&gt;    &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt;    &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt;    &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;\n\n根据name注入@Repository(&quot;myUserDao&quot;)public class UserDaoImpl implements UserDao &#123;    @Override    public void print() &#123;        System.out.println(&quot;Dao层执行结束&quot;);    &#125;&#125;\n\n@Servicepublic class UserServiceImpl implements UserService &#123;    @Resource(name = &quot;myUserDao&quot;)    private UserDao myUserDao;    @Override    public void out() &#123;        myUserDao.print();        System.out.println(&quot;Service层执行结束&quot;);    &#125;&#125;\n\n全注解开发// 添加配置注解@Configuration// 扫描包// 可以通过&#123;&#125;的方式添加多个包@ComponentScan(&quot;com.atguigu.spring6&quot;)public class SpringConfig &#123;&#125;\n\n测试类\n@Testpublic void testAllAnnotation()&#123;    ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);    User user = context.getBean(User.class);    logger.info(&quot;执行成功&quot;);&#125;","categories":["java"],"tags":["Spring"]},{"title":"Spring整合Junit5实现自动getBean","url":"/2023/03/11/Spring%E6%95%B4%E5%90%88Junit5%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8getBean/","content":"整合JUnit5\n// 使用JUnit5省去此类操作ApplicationContext context = new ClassPathXmlApplicationContext(&quot;xxx.xml&quot;);Xxxx xxx = context.getBean(Xxxx.class);\n\n添加依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;    &lt;version&gt;5.9.0&lt;/version&gt;&lt;/dependency&gt;\n\n两种方式实现\n//方式一//@ExtendWith(SpringExtension.class)//@ContextConfiguration(&quot;classpath:beans.xml&quot;)//方式二@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)public class SpringJUnit5Test &#123;    @Autowired    private User user;    @Test    public void testUser()&#123;        System.out.println(user);    &#125;&#125;\n\n","categories":["java"],"tags":["Spring"]},{"title":"Trie树-并查集","url":"/2023/02/09/Trie%E6%A0%91-%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"并查集通常用于\n\n将两个集合合并\n查询两个元素是否在同一个集合中基本原理：每个集合用一颗树来表示，每个节点都存储其父节点，树根的编号就是集合的编号。判断树根：p[x] == x求x的集合编号：while(p[x] != x) x = p[x]，优化，进行路径压缩，一次找到根节点，将路径上所有点都直接指向根节点。这样可以基本保证O(1)的时间复杂度。合并两个集合：p[x] = y#include&lt;iostream&gt;using namespace std;const int N = 100010;//父节点元素int p[N];//返回x所在集合的编号//返回x的祖宗节点 + 路径压缩int find(int x) &#123;    if(x != p[x]) p[x] = find([px]);    return p[x];&#125;\n\nTrie树用来快速存储和查找字符串集合的数据结构Trie的插入和查询操作\n/*假设有下标为x的点son[x][]为下标x节点的所有子节点，son[x][0]就是x的第0个儿子cnt[x]是指以x结尾的点有多少个*/#include&lt;iostream&gt;using namespace std;int N = 100010;int son[N][26], cnt[N], idx;void insert(char[] str) &#123;    int p = 0;    for(int i = 0; str[i]; i++) &#123;        int u = str[i] - ‘a’;        if(!son[p][u]) son[p][u] = ++idx;        p = son[p]][u];    &#125;    cnt[p]++;&#125; int query(char[] str) &#123;    int p = 0;    for(int i = 0; str[i]; i++) &#123;        int u = str[i] - ‘a’;        if(!str[p][u]) return 0;        p = son[p][u];    &#125;    return cnt[p];&#125;\n\n","categories":["基础算法复习"],"tags":["算法"]},{"title":"java多线程（一）","url":"/2023/03/01/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/","content":"第一集\n\n继承Thread类实现多线程public class ThreadDemo extends Thread&#123;    @Override    public void run()&#123;        for(int i  = 0; i &lt; 20; i++)&#123;            System.out.println(i + &quot;---子线程&quot;);        &#125;    &#125;    public static void main(String[] args)    &#123;        ThreadDemo threadTest = new ThreadDemo();        threadTest.start();        for(int i  = 0; i &lt; 20; i++)&#123;            System.out.println(i + &quot;---主线程&quot;);        &#125;    &#125;&#125;/*输出结果0---子线程1---子线程2---子线程3---子线程4---子线程5---子线程6---子线程7---子线程8---子线程0---主线程9---子线程1---主线程2---主线程3---主线程4---主线程5---主线程6---主线程10---子线程7---主线程8---主线程9---主线程10---主线程11---主线程12---主线程13---主线程14---主线程15---主线程11---子线程16---主线程12---子线程13---子线程14---子线程15---子线程16---子线程17---子线程18---子线程19---子线程17---主线程18---主线程19---主线程 */\n\n实现Runnable接口（推荐使用）public class ThreadDemo implements Runnable &#123;    @Override    public void run() &#123;        for (int i = 1; i &lt;= 20; i++) &#123;            System.out.println(i + &quot;---子线程&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        ThreadDemo threadTest = new ThreadDemo();        new Thread(threadTest).start();        for (int i = 1; i &lt;= 20; i++) &#123;            System.out.println(i + &quot;---主线程&quot;);        &#125;    &#125;&#125;/*输出结果1---子线程2---子线程3---子线程4---子线程5---子线程6---子线程7---子线程8---子线程1---主线程2---主线程3---主线程9---子线程4---主线程5---主线程6---主线程7---主线程8---主线程9---主线程10---主线程11---主线程10---子线程11---子线程12---子线程13---子线程14---子线程15---子线程16---子线程12---主线程13---主线程14---主线程17---子线程15---主线程16---主线程17---主线程18---主线程18---子线程19---主线程19---子线程20---子线程20---主线程*/\n\n初识并发问题public class ThreadDemo implements Runnable &#123;    private int ticketNum = 10;    @Override    public void run() &#123;        while (true) &#123;            if (ticketNum &lt;= 0) break;            //模拟延时            try &#123;                Thread.sleep(200);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName() + &quot;--&gt; 拿到了第&quot; + ticketNum-- + &quot;张票&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        ThreadDemo ticket = new ThreadDemo();        new Thread(ticket, &quot;张三&quot;).start();        new Thread(ticket, &quot;李四&quot;).start();        new Thread(ticket, &quot;黄牛&quot;).start();    &#125;&#125;/*输出结果黄牛--&gt; 拿到了第9张票张三--&gt; 拿到了第10张票李四--&gt; 拿到了第9张票张三--&gt; 拿到了第8张票黄牛--&gt; 拿到了第8张票李四--&gt; 拿到了第8张票黄牛--&gt; 拿到了第7张票张三--&gt; 拿到了第6张票李四--&gt; 拿到了第5张票张三--&gt; 拿到了第3张票黄牛--&gt; 拿到了第4张票李四--&gt; 拿到了第4张票李四--&gt; 拿到了第2张票黄牛--&gt; 拿到了第1张票张三--&gt; 拿到了第2张票*///此时多个线程操作同一个对象时，线程不安全，会出现重复抢票的现象\n\n模拟龟兔赛跑问题public class Race implements Runnable &#123;    private static String winnner;    @Override    public void run() &#123;        for (int i = 0; i &lt;= 100; i++) &#123;            boolean flag = gameOver(i);            if (flag) break;            //模拟兔子跑10步后睡觉            if (Thread.currentThread().getName().equals(&quot;兔子&quot;) &amp;&amp; i % 10 == 0) &#123;                try &#123;                    Thread.sleep(3);                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (winnner == null)                System.out.println(Thread.currentThread().getName() + &quot;--&gt;跑了&quot; + i + &quot;步&quot;);        &#125;    &#125;    private boolean gameOver(int steps) &#123;        if (winnner != null) return true;        else &#123;            if (steps &gt;= 100) &#123;                winnner = Thread.currentThread().getName();                System.out.println(&quot;winner is &quot; + winnner);                return true;            &#125;        &#125;        return false;    &#125;    public static void main(String[] args) &#123;        Race race = new Race();        new Thread(race, &quot;兔子&quot;).start();        new Thread(race, &quot;乌龟&quot;).start();    &#125;&#125;\n\nLamda表达式简化函数式接口的调用\npublic class LambdaDemo &#123;    public static void main(String[] args) &#123;        iLike like = () -&gt; &#123;            System.out.println(&quot;This is lambda&quot;);        &#125;;        like.lambda();    &#125;&#125;// 1. 定义一个函数式接口（只有一个抽象方法的接口）interface iLike &#123;    void lambda();&#125;\n\n线程停止建议使用flag标志位使得线程停止\npublic class StopDemo implements Runnable &#123;    // 1. 设置标志位    private boolean flag = true;    @Override    public void run() &#123;        int i = 0;        while (flag) &#123;            System.out.println(&quot;Thread running ......&quot; + i++);        &#125;    &#125;    public void stop() &#123;        this.flag = false;    &#125;    public static void main(String[] args) &#123;        StopDemo stopDemo = new StopDemo();        new Thread(stopDemo).start();        for (int i = 0; i &lt; 100; i++) &#123;            System.out.println(&quot;main&quot; + i);            if (i == 90) &#123;                stopDemo.stop();                System.out.println(&quot;线程终止&quot;);            &#125;        &#125;    &#125;&#125;\n\n线程休眠//倒计时模拟import java.text.SimpleDateFormat;import java.util.Date;public class StopDemo &#123;    public static void main(String[] args) &#123;        Date currentTime = new Date(System.currentTimeMillis());        while (true) &#123;            try &#123;                Thread.sleep(1000);                System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(currentTime));                currentTime = new Date(System.currentTimeMillis());            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;\n\nyield线程礼让让线程从运行态转换为就绪态\npublic class YeildDemo &#123;    public static void main(String[] args) &#123;        Myield myield = new Myield();        new Thread(myield, &quot;a&quot;).start();        new Thread(myield, &quot;b&quot;).start();    &#125;&#125;class Myield implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(Thread.currentThread().getName() + &quot;线程开始执行&quot;);        Thread.yield(); // 礼让        System.out.println(Thread.currentThread().getName() + &quot;线程暂停执行&quot;);    &#125;&#125;/*礼让后的执行结果b线程开始执行a线程开始执行b线程暂停执行a线程暂停执行*/\n\n线程强制执行join//抢占其他线程public class joinDemo implements Runnable &#123;    @Override    public void run() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            System.out.println(&quot;插入线程&quot; + i);        &#125;    &#125;    public static void main(String[] args) &#123;        joinDemo joinDemo = new joinDemo();        Thread joinThread = new Thread(joinDemo);        joinThread.start();        for (int i = 0; i &lt; 10; i++) &#123;            if (i == 4) &#123;                try &#123;                    joinThread.join();                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;            System.out.println(&quot;main线程&quot; + i);        &#125;    &#125;&#125;/*输出结果main线程0main线程1main线程2main线程3插入线程0插入线程1插入线程2插入线程3插入线程4插入线程5插入线程6插入线程7插入线程8插入线程9main线程4main线程5main线程6main线程7main线程8main线程9*/\n\n观测线程状态\nNEW：尚未启动的线程状态\nRUNNABLE：在java虚拟机中执行的线程处于此状态\nBLOCKED：被阻塞等待监视器锁定的线程处于此状态\nWAITING：正在等待另一个线程执行特定动作的线程处于此状态\nTIMED_WAITING：正在等待另一个线程动作达到指定等待时间的线程处于此状态\nTERMINATED：已退出的线程处于此状态\n\npublic class joinDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread thread = new Thread(() -&gt; &#123;            for (int i = 0; i &lt; 3; i++) &#123;                try &#123;                    Thread.sleep(1000);                &#125; catch (InterruptedException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;            System.out.println(&quot;线程执行完毕&quot;);        &#125;);        //定义线程状态        Thread.State state = thread.getState();        System.out.println(state); // NEW        thread.start();        state = thread.getState();        System.out.println(state); //RUNNABLE        while (thread.getState() != Thread.State.TERMINATED) &#123;            Thread.sleep(100);            state = thread.getState();            System.out.println(state);        &#125;    &#125;&#125;/*执行结果NEWRUNNABLETIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITINGTIMED_WAITING线程执行完毕TERMINATED*/\n\n线程优先级优先级高的线程不一定先跑，只是先跑的概率比较大\npublic class PriorityDemo implements Runnable &#123;    @Override    public void run() &#123;        System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + Thread.currentThread().getPriority());    &#125;    public static void main(String[] args) &#123;        System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + Thread.currentThread().getPriority());        PriorityDemo priorityDemo = new PriorityDemo();        Thread thread1 = new Thread(priorityDemo, &quot;a&quot;);        Thread thread2 = new Thread(priorityDemo, &quot;b&quot;);        Thread thread3 = new Thread(priorityDemo, &quot;c&quot;);        Thread thread4 = new Thread(priorityDemo, &quot;d&quot;);        Thread thread5 = new Thread(priorityDemo, &quot;e&quot;);        Thread thread6 = new Thread(priorityDemo, &quot;f&quot;);\t\t//设置优先级        thread1.setPriority(Thread.MAX_PRIORITY);        thread1.start();        thread2.setPriority(7);        thread2.start();        thread3.setPriority(6);        thread3.start();        thread4.setPriority(5);        thread4.start();        thread5.setPriority(4);        thread5.start();        thread6.setPriority(3);        thread6.start();    &#125;&#125;/*输出结果main--&gt;5e--&gt;4a--&gt;10d--&gt;5c--&gt;6b--&gt;7f--&gt;3*/\n\n守护线程public class Daemon &#123;    public static void main(String[] args) &#123;        DaemonThread daemonThread = new DaemonThread();        UserThread userThread = new UserThread();        Thread thread = new Thread(daemonThread);        //设置守护线程        thread.setDaemon(true);        thread.start();        new Thread(userThread).start();    &#125;&#125;class DaemonThread implements Runnable &#123;    @Override    public void run() &#123;        while (true) &#123;            try &#123;                Thread.sleep(2000);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            System.out.println(&quot;Daemon thread running&quot;);        &#125;    &#125;&#125;class UserThread implements Runnable &#123;    @Override    public void run() &#123;        int k = 10;        while (k &gt; 0) &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            System.out.println(k + &quot;-user thread running&quot;);            k--;        &#125;    &#125;&#125;/*输出结果10-user thread runningDaemon thread running9-user thread running8-user thread runningDaemon thread running7-user thread running6-user thread runningDaemon thread running5-user thread running4-user thread runningDaemon thread running3-user thread running2-user thread runningDaemon thread running1-user thread running/*\n\n线程同步！多个线程访问同一个对象，并且某些线程还想修改这个对象，此时需要线程同步，线程同步是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程在使用\n形成条件：队列 + 锁\n锁的是共享的对象\n//买票问题解决public class ThreadDemo implements Runnable &#123;    private int ticketNum = 10;    boolean flag = true;    @Override    public void run() &#123;        while (flag) &#123;            try &#123;                buy();                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    //添加synchronized表明是同步方法    private synchronized void buy()&#123;        if(ticketNum &lt;= 0)&#123;            flag = false;            return;        &#125;        System.out.println(Thread.currentThread().getName() + &quot;--&gt; 拿到了第&quot; + ticketNum-- + &quot;张票&quot;);    &#125;    public static void main(String[] args) &#123;        ThreadDemo ticket = new ThreadDemo();        new Thread(ticket, &quot;张三&quot;).start();        new Thread(ticket, &quot;李四&quot;).start();        new Thread(ticket, &quot;黄牛&quot;).start();    &#125;&#125;\n\n死锁多个线程互相占有着对方需要的资源，形成死锁\npublic class DeadLock &#123;    public static void main(String[] args) &#123;        Occupy personA = new Occupy(&quot;a&quot;);        Occupy personB = new Occupy(&quot;b&quot;);        new Thread(personA, &quot;a&quot;).start();        new Thread(personB, &quot;b&quot;).start();    &#125;&#125;class goodA &#123; &#125;class goodB &#123; &#125;class Occupy implements Runnable&#123;    static goodA goodA = new goodA();    static goodB goodB = new goodB();    private String Name;    Occupy(String Name)&#123;        this.Name = Name;    &#125;    @Override    public void run() &#123;        try &#123;            holds();        &#125; catch (InterruptedException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    private void holds() throws InterruptedException &#123;        //代码中，a占据A物品后，休眠3s，在这期间b拿到物品B进入休眠，a休眠结束后物品A已经被B占据，b休眠结束后物品A已被a占据，此时双方都无法拿到另一个物品，造成死锁        if (Name == &quot;a&quot;) &#123;            synchronized (goodA) &#123;                System.out.println(Thread.currentThread().getName() + &quot;占有了&quot; + &quot;物品A&quot;);                Thread.sleep(3000);                synchronized (goodB) &#123;                    System.out.println(Thread.currentThread().getName() + &quot;占有了&quot; + &quot;物品B&quot;);                &#125;            &#125;        &#125; else &#123;            synchronized (goodB) &#123;                System.out.println(Thread.currentThread().getName() + &quot;占有了&quot; + &quot;物品B&quot;);                Thread.sleep(3000);                synchronized (goodA) &#123;                    System.out.println(Thread.currentThread().getName() + &quot;占有了&quot; + &quot;物品A&quot;);                &#125;            &#125;        &#125;    &#125;&#125;\n\n产生死锁的四个必要条件\n\n互斥条件：一个资源每次只能被一个进程使用\n请求与保持条件：一个进程因请求资源而阻塞时，对方获得的资源保持不放\n不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺\n循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系\n\nLock锁显式定义同步锁对象实现同步\nimport java.util.concurrent.locks.ReentrantLock;public class LockDemo implements Runnable &#123;    private int ticketNum = 10;    boolean flag = true;    //定义Lock锁    private final ReentrantLock lock = new ReentrantLock();    @Override    public void run() &#123;        while (flag) &#123;            //加锁            lock.lock();            buy();            //买到一张票后该线程解锁并休眠，让其他人买票            lock.unlock();            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;    &#125;    private void buy()&#123;        if(ticketNum &lt;= 0)&#123;            flag = false;            return;        &#125;        System.out.println(Thread.currentThread().getName() + &quot;--&gt; 拿到了第&quot; + ticketNum-- + &quot;张票&quot;);    &#125;    public static void main(String[] args) &#123;        LockDemo ticket = new LockDemo();        new Thread(ticket, &quot;张三&quot;).start();        new Thread(ticket, &quot;李四&quot;).start();        new Thread(ticket, &quot;黄牛&quot;).start();    &#125;&#125;\n\n生产者消费者问题//管程法//利用缓冲区解决生产者消费者模型public class PCDemo &#123;    public static void main(String[] args) &#123;        SynContainer synContainer = new SynContainer();        new Thread(new Producer(synContainer)).start();        new Thread(new Consumer(synContainer)).start();    &#125;&#125;class Producer implements Runnable &#123;    SynContainer synContainer;    Producer(SynContainer synContainer)&#123;        this.synContainer = synContainer;    &#125;    @Override    public void run() &#123;        for(int i = 0; i &lt; 10; i++)&#123;            try &#123;                synContainer.pushProduct(new Chicken(i));            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            System.out.println(&quot;生产了&quot; + i + &quot;件产品&quot;);        &#125;    &#125;&#125;class Consumer implements Runnable &#123;    SynContainer synContainer = new SynContainer();    Consumer(SynContainer synContainer)&#123;        this.synContainer = synContainer;    &#125;    @Override    public void run() &#123;        for (int i = 0; i &lt; 10; i++) &#123;            try &#123;                System.out.println(&quot;消费了第&quot; + synContainer.popProduct().id + &quot;件产品&quot;);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;        &#125;    &#125;&#125;class Chicken &#123;    public int id;    Chicken(int id)&#123;        this.id = id;    &#125;&#125;class SynContainer &#123;    Chicken[] chickens = new Chicken[10];    private int count = 0;    //生产者生产产品    public synchronized void pushProduct(Chicken chicken) throws InterruptedException &#123;        //容器满，等待消费者消费        if(count == chickens.length)&#123;            //通知消费者，生产等待            this.wait();        &#125;        //没有满，丢入产品        chickens[count++] = chicken;        //有产品，可以通知消费者消费        this.notify();    &#125;    //消费者消费产品    public synchronized Chicken popProduct() throws InterruptedException &#123;        //判断是否可以消费        if(count == 0)&#123;            this.wait();            //等待生产者生产，消费者等待        &#125;        //如果可以消费，取走产品        Chicken chicken = chickens[--count];        //吃完了，通知生产者生产        this.notify();        return chicken;    &#125;&#125;\n\n","categories":["java"],"tags":["java多线程"]},{"title":"第一篇博客","url":"/2023/01/23/myFirstPost/","content":"折腾了许久，终于完成的自己的博客。\n建站之初，计划使用 React + Gin 进行博客的搭建，但最终还是放弃了，自己的审美实在过于糟糕，况且，写前端的时间足够学习很多东西，手撸一个博客对于一名大三在校生而言有些过于浪费时间了。\n最终选用 Hexo 进行博客的搭建，Hexo可以解析 MarkDown 文本，生成静态 HTML 页面，最最最重要的是，Hexo 提供了许多现成的主题，对主题不满意的地方可以直接对 CSS 进行修改，在魔改了两天之后，博客网站的样式终于到了我的审美上。\n博客采用 GitHub Page 进行部署，每一篇文章的更新相当于用 GIT 将代码提交到仓库里，再对仓库的 Custom domain 进行设置，把域名添加到上面，这样就可以直接通过域名对博客进行访问了。\n说到域名，还踩了很多坑，在腾讯云进行域名解析时，可以直接把记录类型设置为 CNAME 之后对 ping 一下仓库的地址，填到记录值上就好了，除此之外要在项目的 Source 文件夹下新建一个CNAME 文件，把域名填到里面，不然每次 commit 都要在仓库里重新绑定域名，离谱的很！\n搭建博客是为了督促自己多学习，多更新技术文章，希望能做到😢\n","categories":["杂语"],"tags":["杂语"]},{"title":"二叉树路径问题","url":"/2023/02/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/","content":"在lc中，经常会遇到二叉树路径问题，此类问题一般使用DFS求解\n\n自顶向下一般路径\nvector&lt;vector&lt;int&gt;&gt;res;void dfs(TreeNode*root,vector&lt;int&gt;path)&#123;    if(!root) return;  //根节点为空直接返回    path.push_back(root-&gt;val);  //作出选择    if(!root-&gt;left &amp;&amp; !root-&gt;right) //如果到叶节点      &#123;        res.push_back(path);        return;    &#125;    dfs(root-&gt;left,path);  //继续递归    dfs(root-&gt;right,path);&#125;\n给定和的路径\nvoid dfs(TreeNode*root, int sum, vector&lt;int&gt; path)&#123;    if (!root)        return;    sum -= root-&gt;val;    path.push_back(root-&gt;val);    if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == 0) //和为0代表找到了等于和的路径    &#123;        res.push_back(path); //路径push进结果        return;    &#125;    dfs(root-&gt;left, sum, path);    dfs(root-&gt;right, sum, path);&#125;\n\n例题路径总和二\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;    public:    vector&lt;vector&lt;int&gt;&gt; res; //结果集    void dfs(TreeNode* root, int sum, vector&lt;int&gt; path)&#123;        if(!root) return;        sum -= root -&gt; val;        path.push_back(root -&gt; val);        //判定叶子节点与和是否相等两个条件        if(!root -&gt; left &amp;&amp; !root -&gt; right &amp;&amp; sum == 0)&#123;            res.push_back(path);            return;        &#125;        dfs(root -&gt; left, sum, path);        dfs(root -&gt; right, sum, path);    &#125;        vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;        vector&lt;int&gt; path;        dfs(root, targetSum, path);        return res;    &#125;&#125;;\n路径总和三\nclass Solution &#123;public:    int rootSum(TreeNode* root, long targetSum) &#123;        if (!root) &#123;            return 0;        &#125;        int ret = 0;        if (root-&gt;val == targetSum) &#123;            ret++;        &#125;         //由于可以不在根节点开始，因此需要递归左右节点        ret += rootSum(root-&gt;left, targetSum - root-&gt;val);        ret += rootSum(root-&gt;right, targetSum - root-&gt;val);        return ret;    &#125;    int pathSum(TreeNode* root, int targetSum) &#123;        if (!root) &#123;            return 0;        &#125;                int ret = rootSum(root, targetSum);        ret += pathSum(root-&gt;left, targetSum);        ret += pathSum(root-&gt;right, targetSum);        return ret;    &#125;&#125;;\n从叶节点开始的最小字符串\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;string&gt; path;    string smallestFromLeaf(TreeNode* root) &#123;        dfs(root, &quot;&quot;);        sort(path.begin(), path.end());        return path[0];    &#125;        void dfs(TreeNode* root, string s)&#123;        if(!root) return;        s += &#x27;a&#x27; + root -&gt; val;        if(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;            reverse(s.begin(), s.end());            path.push_back(s);        &#125;        dfs(root -&gt; left, s);        dfs(root -&gt; right, s);    &#125;&#125;;\n\n非自顶向下二叉树中最大路径和\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    int res = INT_MIN;    int dfs(TreeNode* root)&#123;        if(!root) return 0;        int left = max(dfs(root -&gt; left), 0);        int right = max(dfs(root -&gt; right), 0);        res = max(res, left + right + root -&gt; val);        return max(left + root -&gt; val, right + root -&gt; val);    &#125;        int maxPathSum(TreeNode* root) &#123;        dfs(root);        return res;    &#125;&#125;;","categories":["刷题日记"],"tags":["刷题日记"]},{"title":"分割链表","url":"/2023/02/11/%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/","content":"Leetcode-86分割链表可以看作是快排链表的简化版本\n\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* partition(ListNode* head, int x) &#123;        auto small = new ListNode(-1);        auto large = new ListNode(-1);        auto l = small, r = large;        while(head)&#123;            if(head -&gt; val &lt; x)&#123;                small -&gt; next = head;                small = small -&gt; next;            &#125;else&#123;                large -&gt; next = head;                large= large -&gt; next;            &#125;            head = head -&gt; next;        &#125;        large -&gt; next = NULL;        small -&gt; next = r -&gt; next;        return l -&gt; next;    &#125;&#125;;","categories":["刷题日记"],"tags":["刷题日记"]},{"title":"哈希","url":"/2023/02/09/%E5%93%88%E5%B8%8C/","content":"哈希在题目中通常使用Map容器和Set容器来进行哈希操作，哈希的实现主要有两种，分别是拉链法和开放寻址法（蹲坑法？）\n拉链法对于数x，使用某个质数令x取模后，把余数作为下标存储，发生哈希冲突时，将发生冲突的数像链表一样接到发生冲突的数后面。\n模拟散列表：\n#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 100003;int h[N], e[N], ne[N], idx;void insert(int x)&#123;    int k = (x % N + N) % N;    e[idx] = x;    ne[idx] = h[k];    h[k] = idx ++ ;&#125;bool find(int x)&#123;    int k = (x % N + N) % N;    for (int i = h[k]; i != -1; i = ne[i])        if (e[i] == x)            return true;    return false;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    memset(h, -1, sizeof h);    while (n -- )    &#123;        char op[2];        int x;        scanf(&quot;%s%d&quot;, op, &amp;x);        if (*op == &#x27;I&#x27;) insert(x);        else        &#123;            if (find(x)) puts(&quot;Yes&quot;);            else puts(&quot;No&quot;);        &#125;    &#125;    return 0;&#125;\n\n开放寻址法\n#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 200003, null = 0x3f3f3f3f;int h[N];int find(int x)&#123;    int t = (x % N + N) % N;    while (h[t] != null &amp;&amp; h[t] != x)    &#123;        t ++ ;        if (t == N) t = 0;    &#125;    return t;&#125;int main()&#123;    memset(h, 0x3f, sizeof h);    int n;    scanf(&quot;%d&quot;, &amp;n);    while (n -- )    &#123;        char op[2];        int x;        scanf(&quot;%s%d&quot;, op, &amp;x);        if (*op == &#x27;I&#x27;) h[find(x)] = x;        else        &#123;            if (h[find(x)] == null) puts(&quot;No&quot;);            else puts(&quot;Yes&quot;);        &#125;    &#125;    return 0;&#125;\n\n字符串哈希acwing题目：字符串哈希\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ULL;const int N = 100010, P = 131;int n, m;char str[N];ULL h[N], p[N];ULL get(int l, int r)&#123;    return h[r] - h[l - 1] * p[r - l + 1];&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    scanf(&quot;%s&quot;, str + 1);    p[0] = 1;    for (int i = 1; i &lt;= n; i ++ )    &#123;        h[i] = h[i - 1] * P + str[i];        p[i] = p[i - 1] * P;    &#125;    while (m -- )    &#123;        int l1, r1, l2, r2;        scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);        if (get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;);        else puts(&quot;No&quot;);    &#125;    return 0;&#125;","categories":["基础算法复习"],"tags":["算法"]},{"title":"回溯","url":"/2023/02/20/%E5%9B%9E%E6%BA%AF/","content":"回溯算法常用来处理组合，切割，排列等问题\n\n回溯模板func back(/*参数*/)&#123;    if /*条件*/ &#123;        //到底了，收集结果        return    &#125;    for &#123;        //处理节点        //递归        //回溯操作    &#125;&#125;","categories":["基础算法复习"],"tags":["算法"]},{"title":"堆","url":"/2023/02/09/%E5%A0%86/","content":"堆小根堆下标在1开始每一个点都小于等于左右子节点\n\n树的一位数组存储方式：索引为x的节点，左子节点为2x，右子节点为2x+1\n插入一个元素：在树的最后一个元素后插入，然后根据大小向上移动，heap[++size] = x; up(size)\n堆中的最小值：heap[1]\n堆中删除最小值：先使用最后一个点覆盖掉头节点，再把尾节点删掉，最后下沉头节点heap[1] = heap[size]; size—-; down(1)\n堆中删除任意一个元素：heap[k] = heap[size]; size—-，再根据k位元素变大还是变小使用down(k)或者up(k)\n堆中修改任意一个元素：heap[x] = k;在down(x)或者up(x)\n\n堆排序\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int h[N], cnt;//up操作void up(int u)&#123;    while(u / 2 &amp;&amp; h[u / 2] &lt; h[u]) &#123;        swap(h[u / 2], h[u]);        u /= 2;    &#125;&#125;void down(int u)&#123;    int t = u;    if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;    if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;    if (u != t)    &#123;        swap(h[u], h[t]);        down(t);    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]);    cnt = n;    for (int i = n / 2; i; i -- ) down(i);    while (m -- )    &#123;        printf(&quot;%d &quot;, h[1]);        h[1] = h[cnt -- ];        down(1);    &#125;    puts(&quot;&quot;);    return 0;&#125;\n当需要操作堆中第k个元素时，要加入映射关系acwing模拟堆：\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;const int N = 100010;int h[N], ph[N], hp[N], cnt;void heap_swap(int a, int b)&#123;    swap(ph[hp[a]],ph[hp[b]]);    swap(hp[a], hp[b]);    swap(h[a], h[b]);&#125;void down(int u)&#123;    int t = u;    if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;    if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;    if (u != t)    &#123;        heap_swap(u, t);        down(t);    &#125;&#125;void up(int u)&#123;    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])    &#123;        heap_swap(u, u / 2);        u &gt;&gt;= 1;    &#125;&#125;int main()&#123;    int n, m = 0;    scanf(&quot;%d&quot;, &amp;n);    while (n -- )    &#123;        char op[5];        int k, x;        scanf(&quot;%s&quot;, op);        if (!strcmp(op, &quot;I&quot;))        &#123;            scanf(&quot;%d&quot;, &amp;x);            cnt ++ ;            m ++ ;            ph[m] = cnt, hp[cnt] = m;            h[cnt] = x;            up(cnt);        &#125;        else if (!strcmp(op, &quot;PM&quot;)) printf(&quot;%d\\n&quot;, h[1]);        else if (!strcmp(op, &quot;DM&quot;))        &#123;            heap_swap(1, cnt);            cnt -- ;            down(1);        &#125;        else if (!strcmp(op, &quot;D&quot;))        &#123;            scanf(&quot;%d&quot;, &amp;k);            k = ph[k];            heap_swap(k, cnt);            cnt -- ;            up(k);            down(k);        &#125;        else        &#123;            scanf(&quot;%d%d&quot;, &amp;k, &amp;x);            k = ph[k];            h[k] = x;            up(k);            down(k);        &#125;    &#125;    return 0;&#125;","categories":["基础算法复习"],"tags":["算法"]},{"title":"失败经历","url":"/2023/02/10/%E5%A4%B1%E8%B4%A5%E7%BB%8F%E5%8E%86/","content":"刚去自习室的前几天，就注意到了隔座的女生，不知为何，看到她的第一眼就有种说不出的感觉。纠结了许久，终于在前天女生晚上回家后，在她的桌子上留下了要联系方式的纸条。一晚忐忑后，第二天无事发生，蛮想再争取一下，但想到会打扰到女生，思虑再三还是放弃了。就在今天，终于收到了女生的回复：\n谢谢抱歉也祝你早日上岸\n看到内容后说不上难过，也许女生早有所属，也许现阶段没有认识一个陌生人的精力罢了。萍水相逢，几天后便成了陌生人，难免会有些遗憾。想起上次有这种感觉还是在六年前，不知道下次是什么时候。只希望我的纸条能给女生平淡的备考期带来一丝惊喜吧 ~\n\n\n","categories":["日记"],"tags":["杂语"]},{"title":"快排-归并-二分","url":"/2023/01/30/%E5%BF%AB%E6%8E%92-%E5%BD%92%E5%B9%B6-%E4%BA%8C%E5%88%86/","content":"快速排序\n确定分界点x，通常选取左端点，中间值或右端点\n调整区间，使得左区间都小于等于x，右区间都大于等于x\n递归处理左右两段调整区间的思路：当 q[i] &lt; x 或者 q[j] &gt; x时，双指针不停向中间移动，当两者都不满足条件，且i &lt; j时，交换值void quick_sort(int q[], int l, int r)&#123;    if(l &gt;= r) return;    int x = q[(l + r) / 2], I = l - 1, j = r + 1;    while(i &lt; j)&#123;        do i++; while(q[i] &lt; x);        do j—-; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);     &#125;    quick_sort(q, l, j);    quick_sort(q, j+1, r);&#125; \n\n归并排序\n选取中间点mid = （1 + r） / 2\n递归左右两区间，得到单调递增的左右区间\n归并左右两区间归并区间的思路：开辟新数组tmp，双指针i, j 分别指向两个区间的端点，将i, j指针指向较小的数放入tmp，当某段区间结束时，将另一段区间剩余的数直接接到ans数组最后。void merge_sort(int q[], int l, int r)&#123;    if(l &lt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);    int i = l, j = mid + 1, k = 0;    while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;        if(q[i] &lt;= q[j]) tmp[k++] = q[i++];        else tmp[k++] = q[j++];    &#125;    while(l &lt;= mid) tmp[k++] = q[i++];    while(j &lt;= r) tmp[k++] = q[j++];    for(i = l, j = 0; i &lt; r; i++, j++) q[i] = tmp[j];&#125;\n\n整数二分取中间值时需要注意，如果r = mid则中值取l + r &gt;&gt; 1，如果是l = mid则中值取l + r + 1 &gt;&gt;1题目示例：数的范围给定一个按照升序排列的长度为n的整数数组，以及q个查询。对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。如果数组中不存在该元素，则返回-1 -1。\nint main()&#123;    while(queryCount—-)&#123;        int l = 0, r = n - 1;        while(l &lt; r)&#123;            int mid = l + r &gt;&gt; 1;            if(q[mid] &gt;= x) r = mid;            else l = mid + 1;         &#125;        if(q[l] != x) cout &lt;&lt; “-1 -1” &lt;&lt; endl;        else &#123;            cout &lt;&lt; l &lt;&lt; “ ”;            int l = 0; r = n - 1;             while(l &lt; r)&#123;                int mid = l + r + 1 &gt;&gt; 1;                if(q[mid] &lt;= x) l = mid;                else r = mid - 1;            &#125;            cout &lt;&lt; l &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;\n\n浮点数二分int main()&#123;    double l = 0, r = x;    while(r - 1 &gt; 1e-6)&#123;        double mid = (l + r) / 2;        if(mid * mid &gt;= x) r = mid;        else l = mid;        &#125;    cout &lt;&lt; l;&#125;\n","categories":["基础算法复习"],"tags":["算法"]},{"title":"寄！","url":"/2023/02/09/%E6%80%82/","content":"记录今天，给女生要联系方式失败了，我太怂了啊啊啊！！！\n","categories":["日记"],"tags":["杂语"]},{"title":"剑指offer30.包含min函数的栈","url":"/2023/02/12/%E5%89%91%E6%8C%87offer30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","content":"定义存放最小数的辅助栈，元素顺序与主栈一致\n\nclass MinStack &#123;    stack&lt;int&gt; x_stack;    stack&lt;int&gt; min_stack;public:    MinStack() &#123;        min_stack.push(INT_MAX);    &#125;        void push(int x) &#123;        x_stack.push(x);        min_stack.push(::min(min_stack.top(), x));    &#125;        void pop() &#123;        x_stack.pop();        min_stack.pop();    &#125;        int top() &#123;        return x_stack.top();    &#125;        int min() &#123;        return min_stack.top();    &#125;&#125;;","categories":["刷题日记"],"tags":["刷题日记"]},{"title":"手写一个IoC","url":"/2023/03/11/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAIoC/","content":"手动实现一个IoC，包括自动实例化类，和实现依赖注入\n\n反射public class TestCar &#123;    //1、获取Class对象多种方式    @Test    public void test01() throws Exception &#123;        //1 类名.class        Class clazz1 = Car.class;        //2 对象.getClass()        Class clazz2 = new Car().getClass();        //3 Class.forName(&quot;全路径&quot;)        Class clazz3 = Class.forName(&quot;com.tzuhan.Car&quot;);        //实例化        Car car = (Car)clazz3.getConstructor().newInstance();        System.out.println(car);    &#125;    //2、获取构造方法    @Test    public void test02() throws Exception &#123;        Class clazz = Car.class;        /*        * 获取所有构造        * 获取所有public的构造方法        * getConstructors()\t\t\t\t\t\t* Constructor[] constructors = clazz.getConstructors();        * getDeclaredConstructors()                * 获取所有的构造方法        * Constructor[] constructors = clazz.getDeclaredConstructors();        */        for (Constructor c:constructors) &#123;            System.out.println(&quot;方法名称：&quot;+c.getName()+&quot; 参数个数：&quot;+c.getParameterCount());        &#125;        /*        //指定有参数构造创建对象        * 构造public\t\t* Constructor c1 = clazz.getConstructor(String.class, int.class, String.class);\t\t* Car car1 = (Car)c1.newInstance(&quot;Car_name&quot;, 10, &quot;red&quot;);\t\t*/                /*        * 构造private        * Constructor c2 = clazz.getDeclaredConstructor(String.class, int.class, String.class);        * c2.setAccessible(true);        * Car car2 = (Car)c2.newInstance(&quot;Car_name&quot;, 10, &quot;red&quot;);        */    &#125;    //3、获取属性    @Test    public void test03() throws Exception &#123;        Class clazz = Car.class;        Car car = (Car)clazz.getDeclaredConstructor().newInstance();        //获取所有public属性        Field[] fields1 = clazz.getFields();        //获取所有属性        Field[] fields2 = clazz.getDeclaredFields();    &#125;    //4、获取方法    @Test    public void test04() throws Exception &#123;        Car car = new Car(&quot;Car_name&quot;,10,&quot;black&quot;);        Class clazz = car.getClass();        //1 public方法        Method[] methods = clazz.getMethods();        //2 private方法        Method[] methodsAll = clazz.getDeclaredMethods();    &#125;&#125;\n\n手动实现IoC\n创建两个注解@Bean和@Di分别用来创建对象和实现依赖注入\n\n// @Bean/** 以下两个注解分别表示* @Target(ElementType.TYPE) 在类上使用* @Retention(RetentionPolicy.RUNTIME) 运行时生效*/@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Bean &#123;&#125;\n\n// Di@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Di &#123;&#125;\n\n\n创建ApplicationContext接口，接口中声明getBean方法，并创建实现类\n\npublic interface ApplicationContext &#123;    Object getBean(Class clazz);&#125;\n\n\n创建AnnotationApplicationContext类，实现ApplicationContext接口\n\npublic class AnnotationApplicationContext implements ApplicationContext&#123;    // 创建map集合，存储bean对象，实现IoC中的BeanFactory    private Map&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;();        // 添加getBean方法，返回BeanFactory中对应参数中的类    public Object getBean(Class clazz) &#123;        return beanFactory.get(clazz);    &#125;&#125;\n\n/** 添加构造方法* 构造方法中主要实现获取包绝对路径* 并在最后调用loadBean方法实例化对象* 以及loadDi方法实现依赖注入*/public AnnotationApplicationContext(String basePackage) &#123;    try &#123;        String packageDirName = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;);        Enumeration&lt;URL&gt; dirs =  Thread.currentThread().getContextClassLoader().getResources(packageDirName);        while(dirs.hasMoreElements())&#123;            URL url = dirs.nextElement();            String filePath = URLDecoder.decode(url.getFile(), &quot;utf-8&quot;);            rootPath = filePath.substring(0, filePath.length()-packageDirName.length());            loadBean(new File(filePath));        &#125;    &#125;catch (IOException e) &#123;        throw new RuntimeException(e);    &#125;    loadDi();&#125;\n\n// 实现loadBean方法private void loadBean(File fileParent)&#123;    // 判断是否是文件夹    if(fileParent.isDirectory())&#123;        File[] childFiles = fileParent.listFiles();        if(childFiles == null || childFiles.length == 0) return;        for(File child : childFiles)&#123;            // 如果里面还是文件夹，递归            if(child.isDirectory()) loadBean(child);            else &#123;                // 去掉绝对路径部分                String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1);                if(pathWithClass.contains(&quot;.class&quot;))&#123;                    String fullName = pathWithClass.replaceAll(&quot;\\\\\\\\&quot;, &quot;.&quot;).replace(&quot;.class&quot;, &quot;&quot;);                    try &#123;                        Class aClass = Class.forName(fullName);                        if(!aClass.isInterface())&#123;                            // 判断类中是否有Bean注解                            Bean annotation = (Bean) aClass.getAnnotation(Bean.class);                            if(annotation != null)&#123;                                // 注解不为空的话，将该对象实例化                                Object instance = aClass.newInstance();                                if(aClass.getInterfaces().length &gt; 0)&#123;                                    beanFactory.put(aClass.getInterfaces()[0], instance);                                &#125;else &#123;                                    beanFactory.put(aClass, instance);                                &#125;                            &#125;                        &#125;                    &#125; catch (ClassNotFoundException e) &#123;                        throw new RuntimeException(e);                    &#125; catch (InstantiationException e) &#123;                        throw new RuntimeException(e);                    &#125; catch (IllegalAccessException e) &#123;                        throw new RuntimeException(e);                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n\n// 实现loadDi方法，实现依赖注入private void loadDi()&#123;    for(Map.Entry&lt;Class, Object&gt; entry : beanFactory.entrySet())&#123;        Object obj = entry.getValue();        Class aClass = obj.getClass();        // 获取类中的所有属性        Field[] declaredFields = aClass.getDeclaredFields();        for(Field field : declaredFields)&#123;            // 如果存在Di注解            Di annotation = field.getAnnotation(Di.class);            if(annotation != null) &#123;                // 如果为private，将其设置为可更改                field.setAccessible(true);                try &#123;                    field.set(obj, beanFactory.get(field.getType()));                &#125; catch (IllegalAccessException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;        &#125;    &#125;&#125;\n\n","categories":["java"],"tags":["Spring"]},{"title":"排序链表","url":"/2023/02/11/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/","content":"Leetcode-148起初想要用快排，但lc给的用例太恶心了，总是会超时。快排代码：\n\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* gettail(ListNode* head)&#123;        while(head -&gt; next) head = head -&gt; next;        return head;    &#125;        ListNode* sortList(ListNode* head) &#123;        if(!head || !head -&gt; next) return head;        auto left = new ListNode(-1), mid = new ListNode(-1), right = new ListNode(-1);        auto ltail = left, mtail = mid, rtail = right;        int val = head -&gt; val;        for(auto p = head; p; p = p -&gt; next)&#123;            if(p -&gt; val &lt; val) ltail = ltail -&gt; next = p;            else if(p -&gt; val == val) mtail = mtail -&gt; next = p;            else rtail = rtail -&gt; next = p;        &#125;        ltail -&gt; next = mtail -&gt; next = rtail -&gt; next = NULL;        left -&gt; next = sortList(left -&gt; next);        right -&gt; next = sortList(right -&gt; next);                gettail(left) -&gt; next = mid -&gt; next;        gettail(left) -&gt; next = right -&gt; next;                auto p = left -&gt; next;        delete left;        delete mid;        delete right;        return p;    &#125;&#125;;\n最后使用归并来解决问题\nclass Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        if (!head || !head-&gt;next) return head;        auto slow = head, fast = head;        while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)            slow = slow-&gt;next, fast = fast-&gt;next-&gt;next;        fast = slow-&gt;next, slow-&gt;next = nullptr;        return merge(sortList(head), sortList(fast));    &#125;private:    ListNode* merge(ListNode* l1, ListNode* l2) &#123;        ListNode sub(0), *ptr = &amp;sub;        while (l1 &amp;&amp; l2) &#123;            auto &amp;node = l1-&gt;val &lt; l2-&gt;val ? l1 : l2;            ptr = ptr-&gt;next = node, node = node-&gt;next;        &#125;        ptr-&gt;next = l1 ? l1 : l2;        return sub.next;    &#125;&#125;;","categories":["刷题日记"],"tags":["刷题日记"]},{"title":"树-图","url":"/2023/02/09/%E6%A0%91-%E5%9B%BE/","content":"树和图的存储有向图的存储方式有：\n\n邻接矩阵（不常用）\n邻接表（常用）：每个点都是一个单链表图和树的遍历方式同样是深度优先遍历和广度优先遍历深度优先遍历代码中，h数组表示每个点，ne表示该点下一个点的索引，e表示所有的边，idx表示当前点的索引。#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 100010, M = 2 * N;int h[N], e[M], ne[N], idx;bool st[N];void dfs(int u)&#123;    //表示当前点已经遍历过了    st[u] = true;    for(int i = h[u]; i != -1; i = ne[i])&#123;        int j = e[i];        if(!st[u]) dfs(j);    &#125;&#125;int main()&#123;    memset(h, -1, sizeof h);    dfs(1);&#125;\n拓扑序列所有起点有指向终点，有向无环图一定存在拓扑序列入度与出度对于某个点而言，所有指向该点的边的值，叫做该点的入度，反之叫做该点的出度。\n\n","categories":["基础算法复习"],"tags":["算法"]},{"title":"留言板","url":"/2023/02/09/%E7%95%99%E8%A8%80%E6%9D%BF/","content":"快来留言吧 ~\n","categories":["留言板"]},{"title":"链表-栈-队列","url":"/2023/02/09/%E9%93%BE%E8%A1%A8-%E6%A0%88-%E9%98%9F%E5%88%97/","content":"数组模拟静态链表使用数组模拟静态链表速度要显著快于使用结构体。\n\n代码中head表示头节点指向的位置，e[N]表示该节点的值，ne[N]表示节点指向的下一个节点的索引，idx表示当前节点的索引，代码中展示了三种链表的基本操作，分别是头节点插入，任意节点插入，与删除。\n#include&lt;iostream&gt;using namespace std;const N = 100010;int head, e[N], ne[N], idx; void init()&#123;    head = -1;    idx = 0;&#125;//在头节点插入void add_to_head(int x) &#123;    e[idx] = x;    ne[idx] = head;    head = idx;    idx++;&#125;//插入到k下标后void insert_k(int k, int x)&#123;    e[idx] = x;    ne[idx] = ne[k];    ne[k] = idx;    idx++&#125;//删除下标为k的点的后面的点void remove_k(int k)&#123;    ne[k] = ne[ne[k]];&#125;int main() &#123;    &#125;\n\n双向链表\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int e[N], l[N], r[N]void init()&#123;    r[0] = 1, l[1] = 0;    idx = 2;&#125;//在k的右边插入一个节点，当想要在k的左边插入节点时，可以写add(l[k], x)void add(int k, int x) &#123;    e[idx] = x;    l[idx] = k;    r[idx] = r[k];    l[r[k]] = idx;    r[k] = idx;    &#125;void remove(int k) &#123;    r[l[k]] = r[k];    l[r[k]] = l[k];&#125;int main()\n\n栈和队列\n#include&lt;iostream&gt;using namespace std;int stk[N], tt;//插入stk[++ tt] = x;//弹出tt—-//判断栈是否为空if(tt &gt; 0) not emptyelse empty栈顶stk[tt]//**********＊***********//队列int q[N], hh, tt//插入q[++tt] = x;//弹出hh++;//判断空if(hh &lt; tt) not emptyelse empty//取出队头元素q[hh]\n\n单调栈例题：找出数组中每个元素左边距离他最近且比他小的元素，没有返回-1思路：如果存在a[x] &lt; a[y] &amp;&amp; x &gt; y那a[y]永远都不会被输出出来，如此一来，可以直接在栈顶往下找，找到后吧新值入栈\n#include&lt;iostream&gt;using namespace std;const int N = 100010int n;int stk[N], tt;int main()&#123;    cin &gt;&gt; n;    for(int i = 0; i &lt; n; i++) &#123;        int x;        cin &gt;&gt; x;        while(tt &amp;&amp; stk[tt] &gt;= x) tt—-;        if(tt) cout &lt;&lt; stk[tt] &lt;&lt; “ ”;        else cout &lt;&lt; -1 &lt;&lt; “ ”;        stk[++t] = x;         &#125;    return 0;   &#125;\n\n\n单调队列滑动窗口问题\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int n, k;int a[N], q[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; k;    for(int i = 0; i &lt; n; i++ ) &#123;        if(hh &lt;= tt &amp;&amp; i - k +1 &gt; q[hh]) h++;        while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) t—-;        q[++t] = i;        if(i &gt;= k - 1) cout &lt;&lt; a[q[hh]];        puts(“”);    &#125;    puts(“”);        hh = 0, tt = -i;    for(int i = 0; i &lt; n; i++) &#123;        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++;        while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) t—-;        q[++t] = i;        if(i &gt;= k - 1) cout &lt;&lt; a[q[hh]];    &#125;    puts(“”);&#125;","categories":["基础算法复习"],"tags":["算法"]},{"title":"高精度-前缀和-差分","url":"/2023/02/09/%E9%AB%98%E7%B2%BE%E5%BA%A6-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/","content":"高精度大整数存储：使用数组存取大整数，由于在数组的末尾添加值要比在开头添加容易，因此数组的0位一般存取大整数的个位。高精度在很多需要求补位的题目中会遇到，详情见Leetcode。高精度加法：代码中使用k表示进位，每次循环计算两数相加结果和k\n\nvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size() || i &lt; B.size(); i++)&#123;        //A + B结果存到t中        if(i &lt; A.size()) t += A[i];        if(i &lt; B.size()) t += B[i];                //个位存到C中        C.push_back(t % 10);                //如果t &gt; 10, t取进位        t /= 10;    &#125;    if(t) C.push_back(t);    return C;&#125;\n\n高精度减法：\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size() || i &lt; B.size(); i++)&#123;        //t 等于被减数减去借位        t = A[i] - t;        if(i &lt; B.size()) t -= B[i];        C.push_back((t + 10) % 10);                //如果 t &lt; 0 证明存在借位        if(t &lt; 0) t = 1;        else t = 0;    &#125;    //把结果前面的0去掉    while(C.size() &gt; 1 &amp;&amp; c.back() == 0) C.pop_back();    return C;&#125;\n高精度乘法：\nvector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, b)&#123;    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size() || t; i++)&#123;        if(i &lt; A.size()) t += A[i] * b;        C.push_back(t % 10);        t /= 10;    &#125;    return 10;&#125;\n高精度除法：\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123;    vector&lt;int&gt; C;    r = 0;    for(int i = A.size() - 1; i &gt;= 0; i ++)&#123;        r = r * 10 + A[i];        C.push_back(r / b);        r %= b;    &#125;    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;&#125;\n\n前缀和for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];for(int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i];\n差分差分为前缀和的逆运算，假设存在a[], b[]，使得a[i] = b[1] + b[2] + … + b[i]，构造方法为b[i] = a[i] - a[i - 1]\n","categories":["基础算法复习"],"tags":["算法"]}]