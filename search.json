[{"title":"01èƒŒåŒ…é—®é¢˜","url":"/2023/02/10/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","content":"ä»Šå¤©å¼€å§‹äº†åŠ¨æ€è§„åˆ’çš„å­¦ä¹ ï¼Œçœ‹ç€yæ€»çš„é—«æ°DPåˆ†ææ³•ï¼Œå­¦ä¼šäº†æœ€åŸºç¡€çš„01èƒŒåŒ…é—®é¢˜ã€‚\n\n01èƒŒåŒ…é—®é¢˜#include&lt;iostream&gt;using namespace std;const int N = 1010;int n, m;int v[N], w[N];int dp[N][N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; v[i] &gt;&gt; w[i];    for(int i = 1; i &lt;= n; i++)&#123;        for(int j = 0; j &lt;= m; j++) &#123;            dp[i][j] = dp[i - 1][j];            if(v[i] &lt;= j) dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]);        &#125;    &#125;        cout&lt;&lt;dp[n][m];&#125;","categories":["åŸºç¡€ç®—æ³•å¤ä¹ "],"tags":["ç®—æ³•"]},{"title":"DFS-BFS","url":"/2023/02/09/DFS-BFS/","content":"æ·±åº¦ä¼˜å…ˆæœç´¢ä¸å¹¿åº¦ä¼˜å…ˆæœç´¢é€šå¸¸ç”¨äºæ ‘å’Œå›¾çš„æ“ä½œï¼Œç»å…¸æ·±åº¦ä¼˜å…ˆæœç´¢ä¾‹é¢˜å¦‚å…«çš‡åé—®é¢˜ã€‚\n\n\næ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰ä»æ ‘çš„å¤´èŠ‚ç‚¹å¼€å§‹ï¼Œè‡ªæœ€å·¦æ ‘å¼€å§‹å‘ä¸‹æœç´¢ï¼Œåˆ°è¾¾å¶å­èŠ‚ç‚¹åå›æº¯ï¼Œç›´è‡³æœç´¢å®Œæ¯•ã€‚leetcode200.å²›å±¿æ•°é‡\nclass Solution &#123;public:    int dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i, int j) &#123;        //æ·»åŠ é€’å½’é™å®šæ¡ä»¶        if (i &lt; 0 || j &lt; 0 || i &gt;= grid.size() || j &gt;= grid[0].size() || grid[i][j] == &#x27;0&#x27;) &#123;            return 0;        &#125;        //æœ€é‡è¦çš„ä¸€æ­¥ï¼Œé€’å½’çš„è¿‡ç¨‹ä¸­ï¼Œå°†æ¯ä¸€ä¸ªå²›å±¿çš„æ‰€æœ‰ç‚¹èµ‹å€¼ä¸º0        grid[i][j] = &#x27;0&#x27;;        for (int index = 0; index &lt; 4; ++index) &#123;            int next_i = i + di[index];            int next_j = j + dj[index];            df(grid, next_i,next_j);        &#125;        return 1;    &#125;     int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;        int num = 0;        //å¯¹æ¯ä¸€ä¸ªèŠ‚ç‚¹è¿›è¡Œdfs        for (int i = 0; i &lt; grid.size(); ++i) &#123;            for (int j = 0; j &lt; grid[0].size(); ++j) &#123;                num += dfs(grid, i, j);             &#125;        &#125;        return num;    &#125;private:        int di[4] = &#123;-1,0,1,0&#125;;        int dj[4] = &#123;0,1,0,-1&#125;;&#125;;\nä¾‹é¢˜ï¼šacwing 842.æ’åˆ—æ•°å­—é€šè¿‡é€’å½’ä¸å›æº¯çš„æ€æƒ³å®ç°æ·±åº¦ä¼˜å…ˆæœç´¢\n#include&lt;iostream&gt;using namespace std;const int N = 8;int n, path[N];bool st[N];void dfs(int u)&#123;    //é€’å½’ç»ˆæ­¢çš„æ¡ä»¶ä¸ºæœ€å†…å±‚å¾ªç¯ç»ˆæ­¢    if(u == n)&#123;         for(int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, path[i]);        puts(&quot;&quot;);            &#125;;        for(int i = 1; i &lt;= n; i++)&#123;        if(!st[i])&#123;            path[u] = i;            st[i] = true;            dfs(u + 1);            st[i] = false;        &#125;            &#125;&#125;int main()&#123;    cin &gt;&gt; n;    dfs(0);    return 0;&#125;\n\nå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ä»å¤´èŠ‚ç‚¹å¼€å§‹ï¼Œæœç´¢æ¯ä¸€å±‚çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚acwingè¿·å®«é—®é¢˜\n#include&lt;iostream&gt;#include&lt;cstring&gt;typedef pair&lt;int, int&gt; PIIconst N = 110;//ç»™å®šé«˜åº¦ä¸å®½åº¦int n, m;//å­˜å‚¨å›¾int g[N][N];//è®°å½•æ¯ä¸ªç‚¹è·ç¦»èµ·ç‚¹çš„è·ç¦»int d[N][N];int bfs() &#123;    //ç»™å›¾ä¸­æ‰€æœ‰ç‚¹èµ‹å€¼ä¸º-1ï¼Œ-1ä»£è¡¨è¿˜æ²¡èµ°è¿‡    memset(d, -1, sizeof d);    queue&lt;PII&gt; q;    //å›¾ä¸­ç¬¬ä¸€ä¸ªç‚¹èµ‹å€¼ä¸º0ï¼Œä»£è¡¨èµ·å§‹èµ°åˆ°äº†ç¬¬ä¸€ä¸ªç‚¹    d[0, 0] = 0;    q.push(&#123;0, 0&#125;);    //è®¾ç½®æ–¹å‘    int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;    while(q.size())&#123;        auto t = q.front();        q.pop();                //éå†åˆ°è¾¾çš„æ¯ä¸ªç‚¹çš„å››ä¸ªæ–¹å‘        for(int i = 0; i &lt; 4; i++) &#123;            int x = t.first + dx[i], y = t.second + dy[i];             if(x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] == 0 &amp;&amp; d[x][y] == -1) &#123;            //d[x][y]ç­‰äºä¸Šä¸€ä¸ªèŠ‚ç‚¹åŠ ä¸€            d[x][y] = d[t.first][t.second] + 1;            q.push(&#123;x, y&#125;);        &#125;    &#125;    return d[n - 1][m - 1];&#125;int main()&#123;    for(int i = 0; i &lt; n; i++)        for(int j = 0; j &lt; m; j++)            cin &gt;&gt; g[i][j];    cout &lt;&lt; bfs() &lt;&lt; endl;&#125;","categories":["åŸºç¡€ç®—æ³•å¤ä¹ "],"tags":["ç®—æ³•"]},{"title":"Goæ•°æ®ç»“æ„","url":"/2023/01/30/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"åˆ‡ç‰‡åœ¨Goä¸­ï¼Œä¸€èˆ¬ä½¿ç”¨åˆ‡ç‰‡æ›¿ä»£æ•°ç»„çš„ä½¿ç”¨ï¼ŒGoè®¤ä¸ºæ•°ç»„é•¿åº¦å±äºå…¶ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œè¿™å¯èƒ½å¯¼è‡´[3]intçš„æ•°ç»„ç±»å‹ä¸åŒäºå®šä¹‰ä¸º[4]intçš„ç±»å‹ï¼Œä¹Ÿæ„å‘³ç€ä¸èƒ½ä½¿ç”¨å˜é‡å»æŒ‡å®šæ•°ç»„é•¿åº¦ï¼Œå› ä¸ºå˜é‡å¿…é¡»åœ¨ç¼–è¯‘æ—¶è€Œä¸æ˜¯åœ¨è¿è¡Œæ—¶è§£æã€‚\nåˆ‡ç‰‡çš„å®šä¹‰ï¼š\n\nå¸¦å­—é¢é‡ï¼švar x = []int&#123;1, 2, 3&#125;\nä¸å¸¦å­—é¢é‡ï¼švar x []intï¼Œä¸å¸¦å­—é¢é‡æ—¶ï¼Œç”±äºåˆ‡ç‰‡æ²¡æœ‰è¢«èµ‹å€¼ï¼Œå› æ­¤åˆ‡ç‰‡xè¢«èµ‹äºˆé›¶å€¼nil\n\nåˆ‡ç‰‡ä¸­å¸¸ç”¨æ–¹æ³•:\n\nåˆ‡ç‰‡é•¿åº¦len()ï¼Œlen(x)\nå¢åŠ å…ƒç´ append()ï¼Œå¯ä»¥æ·»åŠ å•ä¸ªå€¼ï¼šx = append(x, 10)ï¼Œä¹Ÿå¯ä»¥æ·»åŠ å¤šä¸ªå€¼x = append(x, 1, 2, 3, 4)ï¼Œæˆ–è€…ä½¿ç”¨â€¦æ“ä½œç¬¦æ·»åŠ åˆ‡ç‰‡ï¼šx = append(x, yâ€¦)\n\nå®¹é‡ï¼šåˆ‡ç‰‡æ˜¯ä¸€ä¸ªæ•°å€¼åºåˆ—ï¼Œåˆ‡ç‰‡ä¸­çš„å€¼å ç”¨å†…å­˜ä¸­çš„è¿ç»­åœ°å€ï¼Œåˆ‡ç‰‡åœ¨è¿ç»­å†…å­˜åœ°å€çš„å¤§å°å°±æ˜¯åˆ‡ç‰‡çš„å®¹é‡ã€‚å®¹é‡å¯èƒ½ä¼šå¤§äºåˆ‡ç‰‡çš„é•¿åº¦ï¼Œå½“æœ€ç»ˆæ‰€éœ€é•¿åº¦è¶…å‡ºå®¹é‡çš„å¤§å°æ—¶ï¼Œappendå‡½æ•°ä½¿ç”¨Goè¿è¡Œæ—¶åˆ†é…ä¸€ä¸ªæœ‰æ›´å¤§å®¹é‡çš„åˆ‡ç‰‡ï¼Œå°†åŸåˆ‡ç‰‡çš„å†…å®¹æ‹·è´åˆ°æ–°åˆ‡ç‰‡ï¼Œå°†éœ€è¦æ·»åŠ çš„å€¼æ·»åŠ åˆ°æ–°åˆ‡ç‰‡çš„æœ«å°¾ï¼Œå¹¶è¿”å›æ–°åˆ‡ç‰‡ã€‚ä½¿ç”¨capå‡½æ•°å¯ä»¥å¾—åˆ°åˆ‡ç‰‡çš„å®¹é‡ã€‚ä»£ç ç¤ºä¾‹ï¼š\nvar x []intfat.Println(x, len(x), cap(x))x = append(x, 10)fat.Println(x, len(x), cap(x))x = append(x, 20)fat.Println(x, len(x), cap(x))x = append(x, 30)fat.Println(x, len(x), cap(x))x = append(x, 40)fat.Println(x, len(x), cap(x))x = append(x, 50)fat.Println(x, len(x), cap(x))answer:[] 0 0[10] 1 1[10 20] 2 2[10 20 30] 3 4[10 20 30 40] 4 4[10 20 30 40 50] 5 8\nåœ¨Goä¸­ï¼Œå¯ä»¥é€šè¿‡makeå‡½æ•°åˆ›å»ºæ‰€éœ€å®¹é‡çš„åˆ‡ç‰‡ã€‚x := make([]int, 5)ï¼Œæ­¤æ—¶ä¼šåˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸º5ï¼Œå®¹é‡ä¸º5çš„æ•´å‹åˆ‡ç‰‡ã€‚ä½¿ç”¨makeåˆ›å»ºåˆ‡ç‰‡åï¼Œä¸å¯ä»¥å†ä½¿ç”¨appendæ·»åŠ åˆå§‹å…ƒç´ ï¼Œå¦‚ä½¿ç”¨x = append(x, 10)ï¼Œæ­¤æ—¶10ä¼šè¢«æ·»åŠ è‡³åˆ‡ç‰‡å°¾éƒ¨ï¼Œåˆ‡ç‰‡çš„å®¹é‡ä¼šå†å¢åŠ ä¸€å€ã€‚å¯ä»¥æŒ‡å®šåˆ‡ç‰‡çš„å®¹é‡ï¼šx := make([]int, 5, 10)ï¼Œæ­¤æ—¶åˆ›å»ºäº†ä¸€ä¸ªé•¿åº¦ä¸º5ï¼Œå®¹é‡ä¸º10çš„åˆ‡ç‰‡ã€‚ä¹Ÿå¯ä»¥åˆ›å»ºé•¿åº¦ä¸º0çš„åˆ‡ç‰‡ï¼Œx := make([]int, 0, 5)ï¼Œæ­¤æ—¶å¯ä»¥é€šè¿‡appendæ–¹æ³•å‘åˆ‡ç‰‡å†…è¿½åŠ æ•°æ®ã€‚\næ´¾ç”Ÿåˆ‡ç‰‡ï¼šåœ¨åˆ‡ç‰‡å†…ä½¿ç”¨:æ¥ç”Ÿæˆæ´¾ç”Ÿåˆ‡ç‰‡ã€‚\nx := []int&#123;1, 2, 3, 4&#125;y := x[:2]fmt.Println(y)answer:[1 2]\nåˆ‡ç‰‡æœ‰æ—¶ä¼šå…±äº«å†…å­˜ï¼Œå­åˆ‡ç‰‡çš„å®¹é‡æ˜¯åŸåˆ‡ç‰‡çš„å®¹é‡å‡å»åˆ‡ç‰‡çš„åç§»é‡ï¼Œå› æ­¤ï¼ŒåŸåˆ‡ç‰‡ä¸ºä½¿ç”¨å®¹é‡ä¼šå’Œå­åˆ‡ç‰‡å…±äº«ã€‚å½“æ”¹å˜xåˆ‡ç‰‡æ—¶ï¼Œyä¹Ÿä¼šéšä¹‹æ”¹å˜ã€‚\nå­—ç¬¦ä¸²ï¼Œå­—ç¬¦å’Œå­—èŠ‚å‚ç…§åˆ‡ç‰‡ï¼Œå­—ç¬¦ä¸²åŒæ ·æœ‰æ´¾ç”Ÿè¡¨è¾¾å¼æ¥è·å–å­ä¸²\nMapåˆ›å»ºé›¶å€¼æ˜ å°„ï¼švar nilMap map[string]intåˆ›å»ºå­—é¢é‡æ˜ å°„ï¼štotalMap := map[string]int&#123;&#125;\nMapçš„è¯»å†™æ“ä½œï¼š\ndemoMap := map[string]int&#123;&#125;demoMap[â€œAmyâ€] = 98demoMap[â€œTomâ€] = 90fmt.Println(demoMap[â€œTomâ€])answer:90\nå¦‚æœå°è¯•è¯»å–Mapä¸­ä¸å­˜åœ¨çš„é”®ï¼Œä¼šè¿”å›0å€¼ï¼Œä¸ºäº†åˆ¤æ–­é›¶å€¼æ˜¯ç”±äºè¯¥é”®ä¸å­˜åœ¨è¿˜æ˜¯è¯¥é”®ä¸é›¶å€¼ç›¸å…³è”ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨okæ¨¡å¼ã€‚\n//æ¥ä¸Šè¿°ä»£ç v, ok := demoMap[â€œAmyâ€]fmt.Println(v, ok)answer:98, true\n\ndeleteå‡½æ•°å¯ä»¥åˆ é™¤Mapä¸­çš„é”®å€¼delete(demoMap, â€œAmyâ€)\næ˜ å°„æ¨¡æ‹Ÿé›†åˆï¼š\nintSet = map[int]bool&#123;&#125;vals := []int&#123;1, 3, 3, 5, 2, 9, 8&#125;for _, v := range vals &#123;    intSet[v] = true;&#125;\nå› ä¸ºæ˜ å°„ä¸­ä¸ä¼šå­˜åœ¨ç›¸åŒçš„é”®ï¼Œå› æ­¤æ‰€æœ‰ç›¸åŒçš„å€¼åªä¼šè¢«å­˜æ”¾ä¸€æ¬¡ï¼Œå½“è®¿é—®ä¸å­˜åœ¨çš„é”®æ—¶ï¼Œä¼šè¿”å›é›¶å€¼ï¼Œå¯¹åº”boolçš„false\nç»“æ„ä½“å¸¸è§„ç»“æ„ä½“çš„å®šä¹‰ä¸è®¿é—®ï¼š\ntype person struct&#123;    name string    age int    sex string&#125;//ä»¥ä¸‹ä¸¤ç§æ–¹å¼éƒ½ä¼šå°†ç»“æ„ä½“èµ‹å€¼é›¶å€¼var Tom personAmy := person&#123;&#125;//éç©ºå­—é¢é‡èµ‹å€¼Sam := person&#123;    name: â€œSamâ€,    age: 19,&#125;Tom.name = â€œTomâ€\nåŒ¿åç»“æ„ä½“ï¼š\nvar person struct &#123;    name string    age int    sex string   &#125;\n\næµç¨‹æ§åˆ¶for - rangeï¼š\ntmp := []int&#123;3, 4, 5&#125;for i, v := range tmp&#123;    fmt.Println(i, v)&#125;answer:0 31 42 5\nå½“ä¸éœ€è¦è·å–ç´¢å¼•æ—¶ï¼Œå¯ä»¥ä½¿ç”¨_æ¥ä»£æ›¿\nåœ¨åµŒå¥—å¾ªç¯ä¸­ï¼Œå¯ä»¥ä½¿ç”¨outeræ ‡ç­¾è·³å‡ºæœ€å¤–å±‚å¾ªç¯\n","categories":["GoåŸºç¡€å¤ä¹ "],"tags":["Go"]},{"title":"Trieæ ‘-å¹¶æŸ¥é›†","url":"/2023/02/09/Trie%E6%A0%91-%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"å¹¶æŸ¥é›†é€šå¸¸ç”¨äº\n\nå°†ä¸¤ä¸ªé›†åˆåˆå¹¶\næŸ¥è¯¢ä¸¤ä¸ªå…ƒç´ æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆä¸­åŸºæœ¬åŸç†ï¼šæ¯ä¸ªé›†åˆç”¨ä¸€é¢—æ ‘æ¥è¡¨ç¤ºï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½å­˜å‚¨å…¶çˆ¶èŠ‚ç‚¹ï¼Œæ ‘æ ¹çš„ç¼–å·å°±æ˜¯é›†åˆçš„ç¼–å·ã€‚åˆ¤æ–­æ ‘æ ¹ï¼šp[x] == xæ±‚xçš„é›†åˆç¼–å·ï¼šwhile(p[x] != x) x = p[x]ï¼Œä¼˜åŒ–ï¼Œè¿›è¡Œè·¯å¾„å‹ç¼©ï¼Œä¸€æ¬¡æ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼Œå°†è·¯å¾„ä¸Šæ‰€æœ‰ç‚¹éƒ½ç›´æ¥æŒ‡å‘æ ¹èŠ‚ç‚¹ã€‚è¿™æ ·å¯ä»¥åŸºæœ¬ä¿è¯O(1)çš„æ—¶é—´å¤æ‚åº¦ã€‚åˆå¹¶ä¸¤ä¸ªé›†åˆï¼šp[x] = y#include&lt;iostream&gt;using namespace std;const int N = 100010;//çˆ¶èŠ‚ç‚¹å…ƒç´ int p[N];//è¿”å›xæ‰€åœ¨é›†åˆçš„ç¼–å·//è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹ + è·¯å¾„å‹ç¼©int find(int x) &#123;    if(x != p[x]) p[x] = find([px]);    return p[x];&#125;\n\nTrieæ ‘ç”¨æ¥å¿«é€Ÿå­˜å‚¨å’ŒæŸ¥æ‰¾å­—ç¬¦ä¸²é›†åˆçš„æ•°æ®ç»“æ„Trieçš„æ’å…¥å’ŒæŸ¥è¯¢æ“ä½œ\n/*å‡è®¾æœ‰ä¸‹æ ‡ä¸ºxçš„ç‚¹son[x][]ä¸ºä¸‹æ ‡xèŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹ï¼Œson[x][0]å°±æ˜¯xçš„ç¬¬0ä¸ªå„¿å­cnt[x]æ˜¯æŒ‡ä»¥xç»“å°¾çš„ç‚¹æœ‰å¤šå°‘ä¸ª*/#include&lt;iostream&gt;using namespace std;int N = 100010;int son[N][26], cnt[N], idx;void insert(char[] str) &#123;    int p = 0;    for(int i = 0; str[i]; i++) &#123;        int u = str[i] - â€˜aâ€™;        if(!son[p][u]) son[p][u] = ++idx;        p = son[p]][u];    &#125;    cnt[p]++;&#125; int query(char[] str) &#123;    int p = 0;    for(int i = 0; str[i]; i++) &#123;        int u = str[i] - â€˜aâ€™;        if(!str[p][u]) return 0;        p = son[p][u];    &#125;    return cnt[p];&#125;\n\n","categories":["åŸºç¡€ç®—æ³•å¤ä¹ "],"tags":["ç®—æ³•"]},{"title":"äºŒå‰æ ‘è·¯å¾„é—®é¢˜","url":"/2023/02/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/","content":"åœ¨lcä¸­ï¼Œç»å¸¸ä¼šé‡åˆ°äºŒå‰æ ‘è·¯å¾„é—®é¢˜ï¼Œæ­¤ç±»é—®é¢˜ä¸€èˆ¬ä½¿ç”¨DFSæ±‚è§£\n\nè‡ªé¡¶å‘ä¸‹ä¸€èˆ¬è·¯å¾„\nvector&lt;vector&lt;int&gt;&gt;res;void dfs(TreeNode*root,vector&lt;int&gt;path)&#123;    if(!root) return;  //æ ¹èŠ‚ç‚¹ä¸ºç©ºç›´æ¥è¿”å›    path.push_back(root-&gt;val);  //ä½œå‡ºé€‰æ‹©    if(!root-&gt;left &amp;&amp; !root-&gt;right) //å¦‚æœåˆ°å¶èŠ‚ç‚¹      &#123;        res.push_back(path);        return;    &#125;    dfs(root-&gt;left,path);  //ç»§ç»­é€’å½’    dfs(root-&gt;right,path);&#125;\nç»™å®šå’Œçš„è·¯å¾„\nvoid dfs(TreeNode*root, int sum, vector&lt;int&gt; path)&#123;    if (!root)        return;    sum -= root-&gt;val;    path.push_back(root-&gt;val);    if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == 0) //å’Œä¸º0ä»£è¡¨æ‰¾åˆ°äº†ç­‰äºå’Œçš„è·¯å¾„    &#123;        res.push_back(path); //è·¯å¾„pushè¿›ç»“æœ        return;    &#125;    dfs(root-&gt;left, sum, path);    dfs(root-&gt;right, sum, path);&#125;\n\nä¾‹é¢˜è·¯å¾„æ€»å’ŒäºŒ\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;    public:    vector&lt;vector&lt;int&gt;&gt; res; //ç»“æœé›†    void dfs(TreeNode* root, int sum, vector&lt;int&gt; path)&#123;        if(!root) return;        sum -= root -&gt; val;        path.push_back(root -&gt; val);        //åˆ¤å®šå¶å­èŠ‚ç‚¹ä¸å’Œæ˜¯å¦ç›¸ç­‰ä¸¤ä¸ªæ¡ä»¶        if(!root -&gt; left &amp;&amp; !root -&gt; right &amp;&amp; sum == 0)&#123;            res.push_back(path);            return;        &#125;        dfs(root -&gt; left, sum, path);        dfs(root -&gt; right, sum, path);    &#125;        vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;        vector&lt;int&gt; path;        dfs(root, targetSum, path);        return res;    &#125;&#125;;\nè·¯å¾„æ€»å’Œä¸‰\nclass Solution &#123;public:    int rootSum(TreeNode* root, long targetSum) &#123;        if (!root) &#123;            return 0;        &#125;        int ret = 0;        if (root-&gt;val == targetSum) &#123;            ret++;        &#125;         //ç”±äºå¯ä»¥ä¸åœ¨æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œå› æ­¤éœ€è¦é€’å½’å·¦å³èŠ‚ç‚¹        ret += rootSum(root-&gt;left, targetSum - root-&gt;val);        ret += rootSum(root-&gt;right, targetSum - root-&gt;val);        return ret;    &#125;    int pathSum(TreeNode* root, int targetSum) &#123;        if (!root) &#123;            return 0;        &#125;                int ret = rootSum(root, targetSum);        ret += pathSum(root-&gt;left, targetSum);        ret += pathSum(root-&gt;right, targetSum);        return ret;    &#125;&#125;;\nä»å¶èŠ‚ç‚¹å¼€å§‹çš„æœ€å°å­—ç¬¦ä¸²\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;string&gt; path;    string smallestFromLeaf(TreeNode* root) &#123;        dfs(root, &quot;&quot;);        sort(path.begin(), path.end());        return path[0];    &#125;        void dfs(TreeNode* root, string s)&#123;        if(!root) return;        s += &#x27;a&#x27; + root -&gt; val;        if(!root -&gt; left &amp;&amp; !root -&gt; right)&#123;            reverse(s.begin(), s.end());            path.push_back(s);        &#125;        dfs(root -&gt; left, s);        dfs(root -&gt; right, s);    &#125;&#125;;\n\néè‡ªé¡¶å‘ä¸‹äºŒå‰æ ‘ä¸­æœ€å¤§è·¯å¾„å’Œ\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    int res = INT_MIN;    int dfs(TreeNode* root)&#123;        if(!root) return 0;        int left = max(dfs(root -&gt; left), 0);        int right = max(dfs(root -&gt; right), 0);        res = max(res, left + right + root -&gt; val);        return max(left + root -&gt; val, right + root -&gt; val);    &#125;        int maxPathSum(TreeNode* root) &#123;        dfs(root);        return res;    &#125;&#125;;","categories":["åˆ·é¢˜æ—¥è®°"],"tags":["åˆ·é¢˜æ—¥è®°"]},{"title":"ç¬¬ä¸€ç¯‡åšå®¢","url":"/2023/01/23/myFirstPost/","content":"æŠ˜è…¾äº†è®¸ä¹…ï¼Œç»ˆäºå®Œæˆçš„è‡ªå·±çš„åšå®¢ã€‚\nå»ºç«™ä¹‹åˆï¼Œè®¡åˆ’ä½¿ç”¨ React + Gin è¿›è¡Œåšå®¢çš„æ­å»ºï¼Œä½†æœ€ç»ˆè¿˜æ˜¯æ”¾å¼ƒäº†ï¼Œè‡ªå·±çš„å®¡ç¾å®åœ¨è¿‡äºç³Ÿç³•ï¼Œå†µä¸”ï¼Œå†™å‰ç«¯çš„æ—¶é—´è¶³å¤Ÿå­¦ä¹ å¾ˆå¤šä¸œè¥¿ï¼Œæ‰‹æ’¸ä¸€ä¸ªåšå®¢å¯¹äºä¸€åå¤§ä¸‰åœ¨æ ¡ç”Ÿè€Œè¨€æœ‰äº›è¿‡äºæµªè´¹æ—¶é—´äº†ã€‚\næœ€ç»ˆé€‰ç”¨ Hexo è¿›è¡Œåšå®¢çš„æ­å»ºï¼ŒHexoå¯ä»¥è§£æ MarkDown æ–‡æœ¬ï¼Œç”Ÿæˆé™æ€ HTML é¡µé¢ï¼Œæœ€æœ€æœ€é‡è¦çš„æ˜¯ï¼ŒHexo æä¾›äº†è®¸å¤šç°æˆçš„ä¸»é¢˜ï¼Œå¯¹ä¸»é¢˜ä¸æ»¡æ„çš„åœ°æ–¹å¯ä»¥ç›´æ¥å¯¹ CSS è¿›è¡Œä¿®æ”¹ï¼Œåœ¨é­”æ”¹äº†ä¸¤å¤©ä¹‹åï¼Œåšå®¢ç½‘ç«™çš„æ ·å¼ç»ˆäºåˆ°äº†æˆ‘çš„å®¡ç¾ä¸Šã€‚\nåšå®¢é‡‡ç”¨ GitHub Page è¿›è¡Œéƒ¨ç½²ï¼Œæ¯ä¸€ç¯‡æ–‡ç« çš„æ›´æ–°ç›¸å½“äºç”¨ GIT å°†ä»£ç æäº¤åˆ°ä»“åº“é‡Œï¼Œå†å¯¹ä»“åº“çš„ Custom domain è¿›è¡Œè®¾ç½®ï¼ŒæŠŠåŸŸåæ·»åŠ åˆ°ä¸Šé¢ï¼Œè¿™æ ·å°±å¯ä»¥ç›´æ¥é€šè¿‡åŸŸåå¯¹åšå®¢è¿›è¡Œè®¿é—®äº†ã€‚\nè¯´åˆ°åŸŸåï¼Œè¿˜è¸©äº†å¾ˆå¤šå‘ï¼Œåœ¨è…¾è®¯äº‘è¿›è¡ŒåŸŸåè§£ææ—¶ï¼Œå¯ä»¥ç›´æ¥æŠŠè®°å½•ç±»å‹è®¾ç½®ä¸º CNAME ä¹‹åå¯¹ ping ä¸€ä¸‹ä»“åº“çš„åœ°å€ï¼Œå¡«åˆ°è®°å½•å€¼ä¸Šå°±å¥½äº†ï¼Œé™¤æ­¤ä¹‹å¤–è¦åœ¨é¡¹ç›®çš„ Source æ–‡ä»¶å¤¹ä¸‹æ–°å»ºä¸€ä¸ªCNAME æ–‡ä»¶ï¼ŒæŠŠåŸŸåå¡«åˆ°é‡Œé¢ï¼Œä¸ç„¶æ¯æ¬¡ commit éƒ½è¦åœ¨ä»“åº“é‡Œé‡æ–°ç»‘å®šåŸŸåï¼Œç¦»è°±çš„å¾ˆï¼\næ­å»ºåšå®¢æ˜¯ä¸ºäº†ç£ä¿ƒè‡ªå·±å¤šå­¦ä¹ ï¼Œå¤šæ›´æ–°æŠ€æœ¯æ–‡ç« ï¼Œå¸Œæœ›èƒ½åšåˆ°ğŸ˜¢\n","categories":["æ‚è¯­"],"tags":["æ‚è¯­"]},{"title":"åˆ†å‰²é“¾è¡¨","url":"/2023/02/11/%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/","content":"Leetcode-86åˆ†å‰²é“¾è¡¨å¯ä»¥çœ‹ä½œæ˜¯å¿«æ’é“¾è¡¨çš„ç®€åŒ–ç‰ˆæœ¬\n\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* partition(ListNode* head, int x) &#123;        auto small = new ListNode(-1);        auto large = new ListNode(-1);        auto l = small, r = large;        while(head)&#123;            if(head -&gt; val &lt; x)&#123;                small -&gt; next = head;                small = small -&gt; next;            &#125;else&#123;                large -&gt; next = head;                large= large -&gt; next;            &#125;            head = head -&gt; next;        &#125;        large -&gt; next = NULL;        small -&gt; next = r -&gt; next;        return l -&gt; next;    &#125;&#125;;","categories":["åˆ·é¢˜æ—¥è®°"],"tags":["åˆ·é¢˜æ—¥è®°"]},{"title":"å‰‘æŒ‡offer30.åŒ…å«minå‡½æ•°çš„æ ˆ","url":"/2023/02/12/%E5%89%91%E6%8C%87offer30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","content":"å®šä¹‰å­˜æ”¾æœ€å°æ•°çš„è¾…åŠ©æ ˆï¼Œå…ƒç´ é¡ºåºä¸ä¸»æ ˆä¸€è‡´\n\nclass MinStack &#123;    stack&lt;int&gt; x_stack;    stack&lt;int&gt; min_stack;public:    MinStack() &#123;        min_stack.push(INT_MAX);    &#125;        void push(int x) &#123;        x_stack.push(x);        min_stack.push(::min(min_stack.top(), x));    &#125;        void pop() &#123;        x_stack.pop();        min_stack.pop();    &#125;        int top() &#123;        return x_stack.top();    &#125;        int min() &#123;        return min_stack.top();    &#125;&#125;;","categories":["åˆ·é¢˜æ—¥è®°"],"tags":["åˆ·é¢˜æ—¥è®°"]},{"title":"å“ˆå¸Œ","url":"/2023/02/09/%E5%93%88%E5%B8%8C/","content":"å“ˆå¸Œåœ¨é¢˜ç›®ä¸­é€šå¸¸ä½¿ç”¨Mapå®¹å™¨å’ŒSetå®¹å™¨æ¥è¿›è¡Œå“ˆå¸Œæ“ä½œï¼Œå“ˆå¸Œçš„å®ç°ä¸»è¦æœ‰ä¸¤ç§ï¼Œåˆ†åˆ«æ˜¯æ‹‰é“¾æ³•å’Œå¼€æ”¾å¯»å€æ³•ï¼ˆè¹²å‘æ³•ï¼Ÿï¼‰\næ‹‰é“¾æ³•å¯¹äºæ•°xï¼Œä½¿ç”¨æŸä¸ªè´¨æ•°ä»¤xå–æ¨¡åï¼ŒæŠŠä½™æ•°ä½œä¸ºä¸‹æ ‡å­˜å‚¨ï¼Œå‘ç”Ÿå“ˆå¸Œå†²çªæ—¶ï¼Œå°†å‘ç”Ÿå†²çªçš„æ•°åƒé“¾è¡¨ä¸€æ ·æ¥åˆ°å‘ç”Ÿå†²çªçš„æ•°åé¢ã€‚\næ¨¡æ‹Ÿæ•£åˆ—è¡¨ï¼š\n#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 100003;int h[N], e[N], ne[N], idx;void insert(int x)&#123;    int k = (x % N + N) % N;    e[idx] = x;    ne[idx] = h[k];    h[k] = idx ++ ;&#125;bool find(int x)&#123;    int k = (x % N + N) % N;    for (int i = h[k]; i != -1; i = ne[i])        if (e[i] == x)            return true;    return false;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    memset(h, -1, sizeof h);    while (n -- )    &#123;        char op[2];        int x;        scanf(&quot;%s%d&quot;, op, &amp;x);        if (*op == &#x27;I&#x27;) insert(x);        else        &#123;            if (find(x)) puts(&quot;Yes&quot;);            else puts(&quot;No&quot;);        &#125;    &#125;    return 0;&#125;\n\nå¼€æ”¾å¯»å€æ³•\n#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 200003, null = 0x3f3f3f3f;int h[N];int find(int x)&#123;    int t = (x % N + N) % N;    while (h[t] != null &amp;&amp; h[t] != x)    &#123;        t ++ ;        if (t == N) t = 0;    &#125;    return t;&#125;int main()&#123;    memset(h, 0x3f, sizeof h);    int n;    scanf(&quot;%d&quot;, &amp;n);    while (n -- )    &#123;        char op[2];        int x;        scanf(&quot;%s%d&quot;, op, &amp;x);        if (*op == &#x27;I&#x27;) h[find(x)] = x;        else        &#123;            if (h[find(x)] == null) puts(&quot;No&quot;);            else puts(&quot;Yes&quot;);        &#125;    &#125;    return 0;&#125;\n\nå­—ç¬¦ä¸²å“ˆå¸Œacwingé¢˜ç›®ï¼šå­—ç¬¦ä¸²å“ˆå¸Œ\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef unsigned long long ULL;const int N = 100010, P = 131;int n, m;char str[N];ULL h[N], p[N];ULL get(int l, int r)&#123;    return h[r] - h[l - 1] * p[r - l + 1];&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    scanf(&quot;%s&quot;, str + 1);    p[0] = 1;    for (int i = 1; i &lt;= n; i ++ )    &#123;        h[i] = h[i - 1] * P + str[i];        p[i] = p[i - 1] * P;    &#125;    while (m -- )    &#123;        int l1, r1, l2, r2;        scanf(&quot;%d%d%d%d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);        if (get(l1, r1) == get(l2, r2)) puts(&quot;Yes&quot;);        else puts(&quot;No&quot;);    &#125;    return 0;&#125;","categories":["åŸºç¡€ç®—æ³•å¤ä¹ "],"tags":["ç®—æ³•"]},{"title":"å¿«æ’-å½’å¹¶-äºŒåˆ†","url":"/2023/01/30/%E5%BF%AB%E6%8E%92-%E5%BD%92%E5%B9%B6-%E4%BA%8C%E5%88%86/","content":"å¿«é€Ÿæ’åº\nç¡®å®šåˆ†ç•Œç‚¹xï¼Œé€šå¸¸é€‰å–å·¦ç«¯ç‚¹ï¼Œä¸­é—´å€¼æˆ–å³ç«¯ç‚¹\nè°ƒæ•´åŒºé—´ï¼Œä½¿å¾—å·¦åŒºé—´éƒ½å°äºç­‰äºxï¼Œå³åŒºé—´éƒ½å¤§äºç­‰äºx\né€’å½’å¤„ç†å·¦å³ä¸¤æ®µè°ƒæ•´åŒºé—´çš„æ€è·¯ï¼šå½“ q[i] &lt; x æˆ–è€… q[j] &gt; xæ—¶ï¼ŒåŒæŒ‡é’ˆä¸åœå‘ä¸­é—´ç§»åŠ¨ï¼Œå½“ä¸¤è€…éƒ½ä¸æ»¡è¶³æ¡ä»¶ï¼Œä¸”i &lt; jæ—¶ï¼Œäº¤æ¢å€¼void quick_sort(int q[], int l, int r)&#123;    if(l &gt;= r) return;    int x = q[(l + r) / 2], I = l - 1, j = r + 1;    while(i &lt; j)&#123;        do i++; while(q[i] &lt; x);        do jâ€”-; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);     &#125;    quick_sort(q, l, j);    quick_sort(q, j+1, r);&#125; \n\nå½’å¹¶æ’åº\né€‰å–ä¸­é—´ç‚¹mid = ï¼ˆ1 + rï¼‰ / 2\né€’å½’å·¦å³ä¸¤åŒºé—´ï¼Œå¾—åˆ°å•è°ƒé€’å¢çš„å·¦å³åŒºé—´\nå½’å¹¶å·¦å³ä¸¤åŒºé—´å½’å¹¶åŒºé—´çš„æ€è·¯ï¼šå¼€è¾Ÿæ–°æ•°ç»„tmpï¼ŒåŒæŒ‡é’ˆi, j åˆ†åˆ«æŒ‡å‘ä¸¤ä¸ªåŒºé—´çš„ç«¯ç‚¹ï¼Œå°†i, jæŒ‡é’ˆæŒ‡å‘è¾ƒå°çš„æ•°æ”¾å…¥tmpï¼Œå½“æŸæ®µåŒºé—´ç»“æŸæ—¶ï¼Œå°†å¦ä¸€æ®µåŒºé—´å‰©ä½™çš„æ•°ç›´æ¥æ¥åˆ°ansæ•°ç»„æœ€åã€‚void merge_sort(int q[], int l, int r)&#123;    if(l &lt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);    int i = l, j = mid + 1, k = 0;    while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;        if(q[i] &lt;= q[j]) tmp[k++] = q[i++];        else tmp[k++] = q[j++];    &#125;    while(l &lt;= mid) tmp[k++] = q[i++];    while(j &lt;= r) tmp[k++] = q[j++];    for(i = l, j = 0; i &lt; r; i++, j++) q[i] = tmp[j];&#125;\n\næ•´æ•°äºŒåˆ†å–ä¸­é—´å€¼æ—¶éœ€è¦æ³¨æ„ï¼Œå¦‚æœr = midåˆ™ä¸­å€¼å–l + r &gt;&gt; 1ï¼Œå¦‚æœæ˜¯l = midåˆ™ä¸­å€¼å–l + r + 1 &gt;&gt;1é¢˜ç›®ç¤ºä¾‹ï¼šæ•°çš„èŒƒå›´ç»™å®šä¸€ä¸ªæŒ‰ç…§å‡åºæ’åˆ—çš„é•¿åº¦ä¸ºnçš„æ•´æ•°æ•°ç»„ï¼Œä»¥åŠqä¸ªæŸ¥è¯¢ã€‚å¯¹äºæ¯ä¸ªæŸ¥è¯¢ï¼Œè¿”å›ä¸€ä¸ªå…ƒç´ kçš„èµ·å§‹ä½ç½®å’Œç»ˆæ­¢ä½ç½®ï¼ˆä½ç½®ä»0å¼€å§‹è®¡æ•°ï¼‰ã€‚å¦‚æœæ•°ç»„ä¸­ä¸å­˜åœ¨è¯¥å…ƒç´ ï¼Œåˆ™è¿”å›-1 -1ã€‚\nint main()&#123;    while(queryCountâ€”-)&#123;        int l = 0, r = n - 1;        while(l &lt; r)&#123;            int mid = l + r &gt;&gt; 1;            if(q[mid] &gt;= x) r = mid;            else l = mid + 1;         &#125;        if(q[l] != x) cout &lt;&lt; â€œ-1 -1â€ &lt;&lt; endl;        else &#123;            cout &lt;&lt; l &lt;&lt; â€œ â€;            int l = 0; r = n - 1;             while(l &lt; r)&#123;                int mid = l + r + 1 &gt;&gt; 1;                if(q[mid] &lt;= x) l = mid;                else r = mid - 1;            &#125;            cout &lt;&lt; l &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;\n\næµ®ç‚¹æ•°äºŒåˆ†int main()&#123;    double l = 0, r = x;    while(r - 1 &gt; 1e-6)&#123;        double mid = (l + r) / 2;        if(mid * mid &gt;= x) r = mid;        else l = mid;        &#125;    cout &lt;&lt; l;&#125;\n","categories":["åŸºç¡€ç®—æ³•å¤ä¹ "],"tags":["ç®—æ³•"]},{"title":"å¤±è´¥ç»å†","url":"/2023/02/10/%E5%A4%B1%E8%B4%A5%E7%BB%8F%E5%8E%86/","content":"åˆšå»è‡ªä¹ å®¤çš„å‰å‡ å¤©ï¼Œå°±æ³¨æ„åˆ°äº†éš”åº§çš„å¥³ç”Ÿï¼Œä¸çŸ¥ä¸ºä½•ï¼Œçœ‹åˆ°å¥¹çš„ç¬¬ä¸€çœ¼å°±æ·±æ·±çš„æ²¦é™·äº†ã€‚çº ç»“äº†è®¸ä¹…ï¼Œç»ˆäºåœ¨å‰å¤©å¥³ç”Ÿæ™šä¸Šå›å®¶åï¼Œæˆ‘åœ¨å¥¹çš„æ¡Œå­ä¸Šç•™ä¸‹äº†è¦è”ç³»æ–¹å¼çš„çº¸æ¡ã€‚ä¸€æ™šå¿å¿‘åï¼Œç¬¬äºŒå¤©æ— äº‹å‘ç”Ÿï¼Œå¥½æƒ³å†äº‰å–ä¸€ä¸‹ï¼Œä½†å¥½æ€•æ‰“æ‰°åˆ°å¥³ç”Ÿã€‚å°±åœ¨ä»Šå¤©ï¼Œç»ˆäºæ”¶åˆ°äº†å¥³ç”Ÿçš„å›å¤ï¼š\nè°¢è°¢æŠ±æ­‰ä¹Ÿç¥ä½ æ—©æ—¥ä¸Šå²¸\nçœ‹åˆ°å†…å®¹åè¯´ä¸ä¸Šéš¾è¿‡ï¼Œåå€’æœ‰äº›é‡Šç„¶ï¼Œå¯èƒ½å¯¹äºè¿™ä¸ªå¥³ç”Ÿæ¥è¯´ï¼Œç°é˜¶æ®µæ²¡æœ‰è®¤è¯†ä¸€ä¸ªé™Œç”Ÿäººçš„ç²¾åŠ›ç½¢äº†ã€‚åªæ˜¯å¯¹äºä¸€ä¸ªèæ°´ç›¸é€¢çš„å¥³ç”Ÿæ¥è¯´ï¼Œæˆ‘è¿æš—æ‹çš„æœºä¼šéƒ½æ²¡æœ‰ï¼Œå‡ å¤©åå°±æˆäº†æ°¸è¿œçš„é™Œç”Ÿäººï¼Œéš¾å…æœ‰äº›é—æ†¾ã€‚æƒ³èµ·ä¸Šæ¬¡æœ‰è¿™ç§æ„Ÿè§‰è¿˜æ˜¯åœ¨å…­å¹´å‰ï¼Œä¸çŸ¥é“ä¸‹æ¬¡æ˜¯ä»€ä¹ˆæ—¶å€™ã€‚åªå¸Œæœ›æˆ‘çš„çº¸æ¡èƒ½ç»™å¥³ç”Ÿå¹³æ·¡çš„å¤‡è€ƒæœŸå¸¦æ¥ä¸€ä¸æƒŠå–œå§ ~\n\n\n","categories":["æ—¥è®°"],"tags":["æ‚è¯­"]},{"title":"å †","url":"/2023/02/09/%E5%A0%86/","content":"å †å°æ ¹å †ä¸‹æ ‡åœ¨1å¼€å§‹æ¯ä¸€ä¸ªç‚¹éƒ½å°äºç­‰äºå·¦å³å­èŠ‚ç‚¹\n\næ ‘çš„ä¸€ä½æ•°ç»„å­˜å‚¨æ–¹å¼ï¼šç´¢å¼•ä¸ºxçš„èŠ‚ç‚¹ï¼Œå·¦å­èŠ‚ç‚¹ä¸º2xï¼Œå³å­èŠ‚ç‚¹ä¸º2x+1\næ’å…¥ä¸€ä¸ªå…ƒç´ ï¼šåœ¨æ ‘çš„æœ€åä¸€ä¸ªå…ƒç´ åæ’å…¥ï¼Œç„¶åæ ¹æ®å¤§å°å‘ä¸Šç§»åŠ¨ï¼Œheap[++size] = x; up(size)\nå †ä¸­çš„æœ€å°å€¼ï¼šheap[1]\nå †ä¸­åˆ é™¤æœ€å°å€¼ï¼šå…ˆä½¿ç”¨æœ€åä¸€ä¸ªç‚¹è¦†ç›–æ‰å¤´èŠ‚ç‚¹ï¼Œå†æŠŠå°¾èŠ‚ç‚¹åˆ æ‰ï¼Œæœ€åä¸‹æ²‰å¤´èŠ‚ç‚¹heap[1] = heap[size]; sizeâ€”-; down(1)\nå †ä¸­åˆ é™¤ä»»æ„ä¸€ä¸ªå…ƒç´ ï¼šheap[k] = heap[size]; sizeâ€”-ï¼Œå†æ ¹æ®kä½å…ƒç´ å˜å¤§è¿˜æ˜¯å˜å°ä½¿ç”¨down(k)æˆ–è€…up(k)\nå †ä¸­ä¿®æ”¹ä»»æ„ä¸€ä¸ªå…ƒç´ ï¼šheap[x] = k;åœ¨down(x)æˆ–è€…up(x)\n\nå †æ’åº\n#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int h[N], cnt;//upæ“ä½œvoid up(int u)&#123;    while(u / 2 &amp;&amp; h[u / 2] &lt; h[u]) &#123;        swap(h[u / 2], h[u]);        u /= 2;    &#125;&#125;void down(int u)&#123;    int t = u;    if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;    if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;    if (u != t)    &#123;        swap(h[u], h[t]);        down(t);    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]);    cnt = n;    for (int i = n / 2; i; i -- ) down(i);    while (m -- )    &#123;        printf(&quot;%d &quot;, h[1]);        h[1] = h[cnt -- ];        down(1);    &#125;    puts(&quot;&quot;);    return 0;&#125;\nå½“éœ€è¦æ“ä½œå †ä¸­ç¬¬kä¸ªå…ƒç´ æ—¶ï¼Œè¦åŠ å…¥æ˜ å°„å…³ç³»acwingæ¨¡æ‹Ÿå †ï¼š\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;const int N = 100010;int h[N], ph[N], hp[N], cnt;void heap_swap(int a, int b)&#123;    swap(ph[hp[a]],ph[hp[b]]);    swap(hp[a], hp[b]);    swap(h[a], h[b]);&#125;void down(int u)&#123;    int t = u;    if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;    if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;    if (u != t)    &#123;        heap_swap(u, t);        down(t);    &#125;&#125;void up(int u)&#123;    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])    &#123;        heap_swap(u, u / 2);        u &gt;&gt;= 1;    &#125;&#125;int main()&#123;    int n, m = 0;    scanf(&quot;%d&quot;, &amp;n);    while (n -- )    &#123;        char op[5];        int k, x;        scanf(&quot;%s&quot;, op);        if (!strcmp(op, &quot;I&quot;))        &#123;            scanf(&quot;%d&quot;, &amp;x);            cnt ++ ;            m ++ ;            ph[m] = cnt, hp[cnt] = m;            h[cnt] = x;            up(cnt);        &#125;        else if (!strcmp(op, &quot;PM&quot;)) printf(&quot;%d\\n&quot;, h[1]);        else if (!strcmp(op, &quot;DM&quot;))        &#123;            heap_swap(1, cnt);            cnt -- ;            down(1);        &#125;        else if (!strcmp(op, &quot;D&quot;))        &#123;            scanf(&quot;%d&quot;, &amp;k);            k = ph[k];            heap_swap(k, cnt);            cnt -- ;            up(k);            down(k);        &#125;        else        &#123;            scanf(&quot;%d%d&quot;, &amp;k, &amp;x);            k = ph[k];            h[k] = x;            up(k);            down(k);        &#125;    &#125;    return 0;&#125;","categories":["åŸºç¡€ç®—æ³•å¤ä¹ "],"tags":["ç®—æ³•"]},{"title":"å¯„ï¼","url":"/2023/02/09/%E6%80%82/","content":"è®°å½•ä»Šå¤©ï¼Œç»™å¥³ç”Ÿè¦è”ç³»æ–¹å¼å¤±è´¥äº†ï¼Œæˆ‘å¤ªæ€‚äº†å•Šå•Šå•Šï¼ï¼ï¼\n","categories":["æ—¥è®°"],"tags":["æ‚è¯­"]},{"title":"æ’åºé“¾è¡¨","url":"/2023/02/11/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/","content":"Leetcode-148èµ·åˆæƒ³è¦ç”¨å¿«æ’ï¼Œä½†lcç»™çš„ç”¨ä¾‹å¤ªæ¶å¿ƒäº†ï¼Œæ€»æ˜¯ä¼šè¶…æ—¶ã€‚å¿«æ’ä»£ç ï¼š\n\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* gettail(ListNode* head)&#123;        while(head -&gt; next) head = head -&gt; next;        return head;    &#125;        ListNode* sortList(ListNode* head) &#123;        if(!head || !head -&gt; next) return head;        auto left = new ListNode(-1), mid = new ListNode(-1), right = new ListNode(-1);        auto ltail = left, mtail = mid, rtail = right;        int val = head -&gt; val;        for(auto p = head; p; p = p -&gt; next)&#123;            if(p -&gt; val &lt; val) ltail = ltail -&gt; next = p;            else if(p -&gt; val == val) mtail = mtail -&gt; next = p;            else rtail = rtail -&gt; next = p;        &#125;        ltail -&gt; next = mtail -&gt; next = rtail -&gt; next = NULL;        left -&gt; next = sortList(left -&gt; next);        right -&gt; next = sortList(right -&gt; next);                gettail(left) -&gt; next = mid -&gt; next;        gettail(left) -&gt; next = right -&gt; next;                auto p = left -&gt; next;        delete left;        delete mid;        delete right;        return p;    &#125;&#125;;\næœ€åä½¿ç”¨å½’å¹¶æ¥è§£å†³é—®é¢˜\nclass Solution &#123;public:    ListNode* sortList(ListNode* head) &#123;        if (!head || !head-&gt;next) return head;        auto slow = head, fast = head;        while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)            slow = slow-&gt;next, fast = fast-&gt;next-&gt;next;        fast = slow-&gt;next, slow-&gt;next = nullptr;        return merge(sortList(head), sortList(fast));    &#125;private:    ListNode* merge(ListNode* l1, ListNode* l2) &#123;        ListNode sub(0), *ptr = &amp;sub;        while (l1 &amp;&amp; l2) &#123;            auto &amp;node = l1-&gt;val &lt; l2-&gt;val ? l1 : l2;            ptr = ptr-&gt;next = node, node = node-&gt;next;        &#125;        ptr-&gt;next = l1 ? l1 : l2;        return sub.next;    &#125;&#125;;","categories":["åˆ·é¢˜æ—¥è®°"],"tags":["åˆ·é¢˜æ—¥è®°"]},{"title":"ç•™è¨€æ¿","url":"/2023/02/09/%E7%95%99%E8%A8%80%E6%9D%BF/","content":"å¿«æ¥ç•™è¨€å§ ~\n","categories":["ç•™è¨€æ¿"]},{"title":"æ ‘-å›¾","url":"/2023/02/09/%E6%A0%91-%E5%9B%BE/","content":"æ ‘å’Œå›¾çš„å­˜å‚¨æœ‰å‘å›¾çš„å­˜å‚¨æ–¹å¼æœ‰ï¼š\n\né‚»æ¥çŸ©é˜µï¼ˆä¸å¸¸ç”¨ï¼‰\né‚»æ¥è¡¨ï¼ˆå¸¸ç”¨ï¼‰ï¼šæ¯ä¸ªç‚¹éƒ½æ˜¯ä¸€ä¸ªå•é“¾è¡¨å›¾å’Œæ ‘çš„éå†æ–¹å¼åŒæ ·æ˜¯æ·±åº¦ä¼˜å…ˆéå†å’Œå¹¿åº¦ä¼˜å…ˆéå†æ·±åº¦ä¼˜å…ˆéå†ä»£ç ä¸­ï¼Œhæ•°ç»„è¡¨ç¤ºæ¯ä¸ªç‚¹ï¼Œneè¡¨ç¤ºè¯¥ç‚¹ä¸‹ä¸€ä¸ªç‚¹çš„ç´¢å¼•ï¼Œeè¡¨ç¤ºæ‰€æœ‰çš„è¾¹ï¼Œidxè¡¨ç¤ºå½“å‰ç‚¹çš„ç´¢å¼•ã€‚#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 100010, M = 2 * N;int h[N], e[M], ne[N], idx;bool st[N];void dfs(int u)&#123;    //è¡¨ç¤ºå½“å‰ç‚¹å·²ç»éå†è¿‡äº†    st[u] = true;    for(int i = h[u]; i != -1; i = ne[i])&#123;        int j = e[i];        if(!st[u]) dfs(j);    &#125;&#125;int main()&#123;    memset(h, -1, sizeof h);    dfs(1);&#125;\næ‹“æ‰‘åºåˆ—æ‰€æœ‰èµ·ç‚¹æœ‰æŒ‡å‘ç»ˆç‚¹ï¼Œæœ‰å‘æ— ç¯å›¾ä¸€å®šå­˜åœ¨æ‹“æ‰‘åºåˆ—å…¥åº¦ä¸å‡ºåº¦å¯¹äºæŸä¸ªç‚¹è€Œè¨€ï¼Œæ‰€æœ‰æŒ‡å‘è¯¥ç‚¹çš„è¾¹çš„å€¼ï¼Œå«åšè¯¥ç‚¹çš„å…¥åº¦ï¼Œåä¹‹å«åšè¯¥ç‚¹çš„å‡ºåº¦ã€‚\n\n","categories":["åŸºç¡€ç®—æ³•å¤ä¹ "],"tags":["ç®—æ³•"]},{"title":"é“¾è¡¨-æ ˆ-é˜Ÿåˆ—","url":"/2023/02/09/%E9%93%BE%E8%A1%A8-%E6%A0%88-%E9%98%9F%E5%88%97/","content":"æ•°ç»„æ¨¡æ‹Ÿé™æ€é“¾è¡¨ä½¿ç”¨æ•°ç»„æ¨¡æ‹Ÿé™æ€é“¾è¡¨é€Ÿåº¦è¦æ˜¾è‘—å¿«äºä½¿ç”¨ç»“æ„ä½“ã€‚\n\nä»£ç ä¸­headè¡¨ç¤ºå¤´èŠ‚ç‚¹æŒ‡å‘çš„ä½ç½®ï¼Œe[N]è¡¨ç¤ºè¯¥èŠ‚ç‚¹çš„å€¼ï¼Œne[N]è¡¨ç¤ºèŠ‚ç‚¹æŒ‡å‘çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„ç´¢å¼•ï¼Œidxè¡¨ç¤ºå½“å‰èŠ‚ç‚¹çš„ç´¢å¼•ï¼Œä»£ç ä¸­å±•ç¤ºäº†ä¸‰ç§é“¾è¡¨çš„åŸºæœ¬æ“ä½œï¼Œåˆ†åˆ«æ˜¯å¤´èŠ‚ç‚¹æ’å…¥ï¼Œä»»æ„èŠ‚ç‚¹æ’å…¥ï¼Œä¸åˆ é™¤ã€‚\n#include&lt;iostream&gt;using namespace std;const N = 100010;int head, e[N], ne[N], idx; void init()&#123;    head = -1;    idx = 0;&#125;//åœ¨å¤´èŠ‚ç‚¹æ’å…¥void add_to_head(int x) &#123;    e[idx] = x;    ne[idx] = head;    head = idx;    idx++;&#125;//æ’å…¥åˆ°kä¸‹æ ‡åvoid insert_k(int k, int x)&#123;    e[idx] = x;    ne[idx] = ne[k];    ne[k] = idx;    idx++&#125;//åˆ é™¤ä¸‹æ ‡ä¸ºkçš„ç‚¹çš„åé¢çš„ç‚¹void remove_k(int k)&#123;    ne[k] = ne[ne[k]];&#125;int main() &#123;    &#125;\n\nåŒå‘é“¾è¡¨\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int e[N], l[N], r[N]void init()&#123;    r[0] = 1, l[1] = 0;    idx = 2;&#125;//åœ¨kçš„å³è¾¹æ’å…¥ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå½“æƒ³è¦åœ¨kçš„å·¦è¾¹æ’å…¥èŠ‚ç‚¹æ—¶ï¼Œå¯ä»¥å†™add(l[k], x)void add(int k, int x) &#123;    e[idx] = x;    l[idx] = k;    r[idx] = r[k];    l[r[k]] = idx;    r[k] = idx;    &#125;void remove(int k) &#123;    r[l[k]] = r[k];    l[r[k]] = l[k];&#125;int main()\n\næ ˆå’Œé˜Ÿåˆ—\n#include&lt;iostream&gt;using namespace std;int stk[N], tt;//æ’å…¥stk[++ tt] = x;//å¼¹å‡ºttâ€”-//åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºif(tt &gt; 0) not emptyelse emptyæ ˆé¡¶stk[tt]//**********ï¼Š***********//é˜Ÿåˆ—int q[N], hh, tt//æ’å…¥q[++tt] = x;//å¼¹å‡ºhh++;//åˆ¤æ–­ç©ºif(hh &lt; tt) not emptyelse empty//å–å‡ºé˜Ÿå¤´å…ƒç´ q[hh]\n\nå•è°ƒæ ˆä¾‹é¢˜ï¼šæ‰¾å‡ºæ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ å·¦è¾¹è·ç¦»ä»–æœ€è¿‘ä¸”æ¯”ä»–å°çš„å…ƒç´ ï¼Œæ²¡æœ‰è¿”å›-1æ€è·¯ï¼šå¦‚æœå­˜åœ¨a[x] &lt; a[y] &amp;&amp; x &gt; yé‚£a[y]æ°¸è¿œéƒ½ä¸ä¼šè¢«è¾“å‡ºå‡ºæ¥ï¼Œå¦‚æ­¤ä¸€æ¥ï¼Œå¯ä»¥ç›´æ¥åœ¨æ ˆé¡¶å¾€ä¸‹æ‰¾ï¼Œæ‰¾åˆ°åå§æ–°å€¼å…¥æ ˆ\n#include&lt;iostream&gt;using namespace std;const int N = 100010int n;int stk[N], tt;int main()&#123;    cin &gt;&gt; n;    for(int i = 0; i &lt; n; i++) &#123;        int x;        cin &gt;&gt; x;        while(tt &amp;&amp; stk[tt] &gt;= x) ttâ€”-;        if(tt) cout &lt;&lt; stk[tt] &lt;&lt; â€œ â€;        else cout &lt;&lt; -1 &lt;&lt; â€œ â€;        stk[++t] = x;         &#125;    return 0;   &#125;\n\n\nå•è°ƒé˜Ÿåˆ—æ»‘åŠ¨çª—å£é—®é¢˜\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int n, k;int a[N], q[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; k;    for(int i = 0; i &lt; n; i++ ) &#123;        if(hh &lt;= tt &amp;&amp; i - k +1 &gt; q[hh]) h++;        while(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tâ€”-;        q[++t] = i;        if(i &gt;= k - 1) cout &lt;&lt; a[q[hh]];        puts(â€œâ€);    &#125;    puts(â€œâ€);        hh = 0, tt = -i;    for(int i = 0; i &lt; n; i++) &#123;        if(hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++;        while(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tâ€”-;        q[++t] = i;        if(i &gt;= k - 1) cout &lt;&lt; a[q[hh]];    &#125;    puts(â€œâ€);&#125;","categories":["åŸºç¡€ç®—æ³•å¤ä¹ "],"tags":["ç®—æ³•"]},{"title":"é«˜ç²¾åº¦-å‰ç¼€å’Œ-å·®åˆ†","url":"/2023/02/09/%E9%AB%98%E7%B2%BE%E5%BA%A6-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86/","content":"é«˜ç²¾åº¦å¤§æ•´æ•°å­˜å‚¨ï¼šä½¿ç”¨æ•°ç»„å­˜å–å¤§æ•´æ•°ï¼Œç”±äºåœ¨æ•°ç»„çš„æœ«å°¾æ·»åŠ å€¼è¦æ¯”åœ¨å¼€å¤´æ·»åŠ å®¹æ˜“ï¼Œå› æ­¤æ•°ç»„çš„0ä½ä¸€èˆ¬å­˜å–å¤§æ•´æ•°çš„ä¸ªä½ã€‚é«˜ç²¾åº¦åœ¨å¾ˆå¤šéœ€è¦æ±‚è¡¥ä½çš„é¢˜ç›®ä¸­ä¼šé‡åˆ°ï¼Œè¯¦æƒ…è§Leetcodeã€‚é«˜ç²¾åº¦åŠ æ³•ï¼šä»£ç ä¸­ä½¿ç”¨kè¡¨ç¤ºè¿›ä½ï¼Œæ¯æ¬¡å¾ªç¯è®¡ç®—ä¸¤æ•°ç›¸åŠ ç»“æœå’Œk\n\nvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size() || i &lt; B.size(); i++)&#123;        //A + Bç»“æœå­˜åˆ°tä¸­        if(i &lt; A.size()) t += A[i];        if(i &lt; B.size()) t += B[i];                //ä¸ªä½å­˜åˆ°Cä¸­        C.push_back(t % 10);                //å¦‚æœt &gt; 10, tå–è¿›ä½        t /= 10;    &#125;    if(t) C.push_back(t);    return C;&#125;\n\né«˜ç²¾åº¦å‡æ³•ï¼š\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size() || i &lt; B.size(); i++)&#123;        //t ç­‰äºè¢«å‡æ•°å‡å»å€Ÿä½        t = A[i] - t;        if(i &lt; B.size()) t -= B[i];        C.push_back((t + 10) % 10);                //å¦‚æœ t &lt; 0 è¯æ˜å­˜åœ¨å€Ÿä½        if(t &lt; 0) t = 1;        else t = 0;    &#125;    //æŠŠç»“æœå‰é¢çš„0å»æ‰    while(C.size() &gt; 1 &amp;&amp; c.back() == 0) C.pop_back();    return C;&#125;\né«˜ç²¾åº¦ä¹˜æ³•ï¼š\nvector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, b)&#123;    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size() || t; i++)&#123;        if(i &lt; A.size()) t += A[i] * b;        C.push_back(t % 10);        t /= 10;    &#125;    return 10;&#125;\né«˜ç²¾åº¦é™¤æ³•ï¼š\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123;    vector&lt;int&gt; C;    r = 0;    for(int i = A.size() - 1; i &gt;= 0; i ++)&#123;        r = r * 10 + A[i];        C.push_back(r / b);        r %= b;    &#125;    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;&#125;\n\nå‰ç¼€å’Œfor(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];for(int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i];\nå·®åˆ†å·®åˆ†ä¸ºå‰ç¼€å’Œçš„é€†è¿ç®—ï¼Œå‡è®¾å­˜åœ¨a[], b[]ï¼Œä½¿å¾—a[i] = b[1] + b[2] + â€¦ + b[i]ï¼Œæ„é€ æ–¹æ³•ä¸ºb[i] = a[i] - a[i - 1]\n","categories":["åŸºç¡€ç®—æ³•å¤ä¹ "],"tags":["ç®—æ³•"]}]